<!doctype HTML>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="codemirror.js"></script>
<script src="runmode.js"></script>
<script src="pyret.js"></script>
<script src="hilite.js"></script>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>2.1.5&nbsp;Statements</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="codemirror.css" title="default"/><link rel="stylesheet" type="text/css" href="pyret.css" title="default"/><link rel="stylesheet" type="text/css" href="styles.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Pyret</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Getting_Started.html" class="tocviewlink" data-pltdoc="x">Getting Started</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Language_Concepts.html" class="tocviewselflink" data-pltdoc="x">Language Concepts</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="Builtins.html" class="tocviewlink" data-pltdoc="x">Builtins</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="Libraries.html" class="tocviewlink" data-pltdoc="x">Libraries</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>2&nbsp;</td><td><a href="Language_Concepts.html" class="tocviewlink" data-pltdoc="x">Language Concepts</a></td></tr></table><div class="tocviewsublist" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1&nbsp;</td><td><a href="s_forms.html" class="tocviewselflink" data-pltdoc="x">Language Constructs</a></td></tr><tr><td align="right">2.2&nbsp;</td><td><a href="testing.html" class="tocviewlink" data-pltdoc="x">Testing</a></td></tr><tr><td align="right">2.3&nbsp;</td><td><a href="equality.html" class="tocviewlink" data-pltdoc="x">equality</a></td></tr><tr><td align="right">2.4&nbsp;</td><td><a href="brands.html" class="tocviewlink" data-pltdoc="x">Brands</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">&#9660;</a></td><td>2.1&nbsp;</td><td><a href="s_forms.html" class="tocviewlink" data-pltdoc="x">Language Constructs</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1.1&nbsp;</td><td><a href="s_program.html" class="tocviewlink" data-pltdoc="x">Programs</a></td></tr><tr><td align="right">2.1.2&nbsp;</td><td><a href="Import_Statements.html" class="tocviewlink" data-pltdoc="x">Import Statements</a></td></tr><tr><td align="right">2.1.3&nbsp;</td><td><a href="Provide_Statements.html" class="tocviewlink" data-pltdoc="x">Provide Statements</a></td></tr><tr><td align="right">2.1.4&nbsp;</td><td><a href="Blocks.html" class="tocviewlink" data-pltdoc="x">Blocks</a></td></tr><tr><td align="right">2.1.5&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Statements</a></td></tr><tr><td align="right">2.1.6&nbsp;</td><td><a href="Expressions.html" class="tocviewlink" data-pltdoc="x">Expressions</a></td></tr><tr><td align="right">2.1.7&nbsp;</td><td><a href="s_annotations.html" class="tocviewlink" data-pltdoc="x">Annotations</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_3&quot;);">&#9658;</a></td><td>2.1.5&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Statements</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_3"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1.5.1&nbsp;</td><td><a href="#%28part._s~3alet-expr%29" class="tocviewlink" data-pltdoc="x">Let Expressions</a></td></tr><tr><td align="right">2.1.5.2&nbsp;</td><td><a href="#%28part._s~3afun-expr%29" class="tocviewlink" data-pltdoc="x">Function Declaration Expressions</a></td></tr><tr><td align="right">2.1.5.3&nbsp;</td><td><a href="#%28part._s~3adata-expr%29" class="tocviewlink" data-pltdoc="x">Data Declarations</a></td></tr><tr><td align="right">2.1.5.4&nbsp;</td><td><a href="#%28part._s~3awhen-exp%29" class="tocviewlink" data-pltdoc="x">When Expressions</a></td></tr><tr><td align="right">2.1.5.5&nbsp;</td><td><a href="#%28part._s~3avar-expr%29" class="tocviewlink" data-pltdoc="x">Variable Declarations</a></td></tr><tr><td align="right">2.1.5.6&nbsp;</td><td><a href="#%28part._s~3aassign-expr%29" class="tocviewlink" data-pltdoc="x">Assignment Statements</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">2.1.5.1<tt>&nbsp;</tt></span><a href="#%28part._s~3alet-expr%29" class="tocsubseclink" data-pltdoc="x">Let Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.5.2<tt>&nbsp;</tt></span><a href="#%28part._s~3afun-expr%29" class="tocsubseclink" data-pltdoc="x">Function Declaration Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.5.3<tt>&nbsp;</tt></span><a href="#%28part._s~3adata-expr%29" class="tocsubseclink" data-pltdoc="x">Data Declarations</a></td></tr><tr><td><span class="tocsublinknumber">2.1.5.4<tt>&nbsp;</tt></span><a href="#%28part._s~3awhen-exp%29" class="tocsubseclink" data-pltdoc="x">When Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.5.5<tt>&nbsp;</tt></span><a href="#%28part._s~3avar-expr%29" class="tocsubseclink" data-pltdoc="x">Variable Declarations</a></td></tr><tr><td><span class="tocsublinknumber">2.1.5.6<tt>&nbsp;</tt></span><a href="#%28part._s~3aassign-expr%29" class="tocsubseclink" data-pltdoc="x">Assignment Statements</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="Blocks.html" title="backward to &quot;2.1.4 Blocks&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="s_forms.html" title="up to &quot;2.1 Language Constructs&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Expressions.html" title="forward to &quot;2.1.6 Expressions&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h5>2.1.5<tt>&nbsp;</tt><a name="(part._.Statements)"></a>Statements</h5><p>There are a number of forms that can only appear as statements in <span class="stt">block</span>s
and <span class="stt">provide</span> expressions:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">stmt: let-expr | fun-expr | data-expr | when-expr</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| var-expr | assign-expr | binop-expr</span></p></td></tr></table></blockquote><h5>2.1.5.1<tt>&nbsp;</tt><a name="(part._s~3alet-expr)"></a>Let Expressions</h5><p>Let expressions are written with an equals sign:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">let-expr: binding "=" binop-expr</span></p></td></tr></table></blockquote><p>A let statement causes the name in the <span class="stt">binding</span> to be put in scope in the
current block, and upon evaluation sets the value to be the result of
evaluating the <span class="stt">binop-expr</span>.  The resulting binding cannot be changed via an
<span class="stt">assign-expr</span>, and cannot be shadowed by other bindings within the same or
nested scopes:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">x = 5</span></p></td></tr><tr><td><p><span class="stt">x := 10</span></p></td></tr><tr><td><p><span class="stt"># Error: x is not assignable</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr></table></blockquote><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">x = 5</span></p></td></tr><tr><td><p><span class="stt">x = 10</span></p></td></tr><tr><td><p><span class="stt"># Error: x defined twice</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr></table></blockquote><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">x = 5</span></p></td></tr><tr><td><p><span class="stt">fun f():</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">x = 10</span></p></td></tr><tr><td><p><span class="stt">end</span></p></td></tr><tr><td><p><span class="stt"># Error: can't use the name x in two nested scopes</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr></table></blockquote><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">fun f():</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">x = 10</span></p></td></tr><tr><td><p><span class="stt">end</span></p></td></tr><tr><td><p><span class="stt">fun g():</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">x = 22</span></p></td></tr><tr><td><p><span class="stt">end</span></p></td></tr><tr><td><p><span class="stt"># Not an error: x is used in two scopes that are not nested</span></p></td></tr></table></blockquote><h5>2.1.5.2<tt>&nbsp;</tt><a name="(part._s~3afun-expr)"></a>Function Declaration Expressions</h5><p>Function declarations have a number of pieces:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">fun-expr: "fun" fun-header ":" doc-string block where-clause "end"</span></p></td></tr><tr><td><p><span class="stt">fun-header: ty-params NAME args return-ann</span></p></td></tr><tr><td><p><span class="stt">ty-params:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">["&lt;" list-ty-param* NAME "&gt;"]</span></p></td></tr><tr><td><p><span class="stt">list-ty-param: NAME ","</span></p></td></tr><tr><td><p><span class="stt">args: (PARENSPACE|PARENNOSPACE) [list-arg-elt* binding] ")"</span></p></td></tr><tr><td><p><span class="stt">list-arg-elt: binding ","</span></p></td></tr><tr><td><p><span class="stt">return-ann: ["-&gt;" ann]</span></p></td></tr><tr><td><p><span class="stt">doc-string: ["doc:" STRING]</span></p></td></tr><tr><td><p><span class="stt">where-clause: ["where:" block]</span></p></td></tr></table></blockquote><p>A function expression is syntactic sugar for a let and an anonymous function
expression.  The statement:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">"fun" ty-params NAME args return-ann ":"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">doc-string</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">block</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where-clause</span></p></td></tr><tr><td><p><span class="stt">"end"</span></p></td></tr></table></blockquote><p>Is equivalent to</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">NAME "=" "fun" ty-params args return-ann ":"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">doc-string</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">block</span></p></td></tr><tr><td><p><span class="stt">"end"</span></p></td></tr></table></blockquote><p>With the <span class="stt">where-clause</span> registered in check mode.  Concretely:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">fun f(x, y):</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">x + y</span></p></td></tr><tr><td><p><span class="stt">end</span></p></td></tr></table></blockquote><p>is equivalent to</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">f = lam(x, y):</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">x + y</span></p></td></tr><tr><td><p><span class="stt">end</span></p></td></tr></table></blockquote><p>See the documentation for <span class="stt">lambda-exprs</span> for an explanation of arguments&rsquo;
and annotations&rsquo; behavior, as well as <span class="stt">doc-strings</span>.</p><h5>2.1.5.3<tt>&nbsp;</tt><a name="(part._s~3adata-expr)"></a>Data Declarations</h5><p>Data declarations define a number of related functions for creating and
manipulating a data type.  Their grammar is:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">data-expr: "data" NAME ty-params data-mixins ":"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">data-variant*</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">data-sharing</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">where-clause</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"end"</span></p></td></tr><tr><td><p><span class="stt">data-mixins: ["deriving" mixins]</span></p></td></tr><tr><td><p><span class="stt">data-variant: "|" NAME variant-members data-with | "|" NAME data-with</span></p></td></tr><tr><td><p><span class="stt">variant-members: (PARENSPACE|PARENNOSPACE) [list-variant-member* variant-member] ")"</span></p></td></tr><tr><td><p><span class="stt">list-variant-member: variant-member ","</span></p></td></tr><tr><td><p><span class="stt">variant-member: ["mutable"|"cyclic"] binding</span></p></td></tr><tr><td><p><span class="stt">data-with: ["with:" fields]</span></p></td></tr><tr><td><p><span class="stt">data-sharing: ["sharing:" fields]</span></p></td></tr></table></blockquote><p>A <span class="stt">data-expr</span> causes a number of new names to be bound in the scope of the
block it is defined in:</p><ul><li><p>The <span class="stt">NAME</span> of the data definition</p></li><li><p><span class="stt">NAME</span>, for each variant of the data definition</p></li><li><p><span class="stt">is-NAME</span>, for each variant of the data definition</p></li></ul><p>For example, in this data definition:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">data BTree:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| node(value :: Number, left :: BTree, right :: BTree)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| leaf(value :: Number)</span></p></td></tr><tr><td><p><span class="stt">end</span></p></td></tr></table></blockquote><p>These names are defined, with the given types:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">BTree :: (Any -&gt; Bool)</span></p></td></tr><tr><td><p><span class="stt">node :: (Number, BTree, BTree -&gt; BTree)</span></p></td></tr><tr><td><p><span class="stt">is-node :: (Any -&gt; Bool)</span></p></td></tr><tr><td><p><span class="stt">leaf :: (Number -&gt; BTree)</span></p></td></tr><tr><td><p><span class="stt">is-leaf :: (Any -&gt; Bool)</span></p></td></tr></table></blockquote><p>We call <span class="stt">node</span> and <span class="stt">leaf</span> the <span style="font-style: italic">constructors</span> of <span class="stt">BTree</span>, and they
construct values with the named fields.  They will refuse to create the value
if fields that don&rsquo;t match the annotations are given.  As with all annotations,
they are optional.  The constructed values can have their fields accessed with
<a href="Expressions.html#%28part._s~3adot-expr%29" data-pltdoc="x">dot expressions</a>.</p><p>The function <span class="stt">BTree</span> is a <span style="font-style: italic">detector</span> for values created from this data
definition, and can be used as an annotation to check for values created by the
constructors of <span class="stt">BTree</span>.  <span class="stt">BTree</span> returns true when provided values
created by <span class="stt">node</span> or <span class="stt">leaf</span>, but no others.</p><p>The functions <span class="stt">is-node</span> and <span class="stt">is-leaf</span> are detectors for the values
created by the individual constructors: <span class="stt">is-node</span> will only return <span class="stt">true</span>
for values created by calling <span class="stt">node</span>, and correspondingly for <span class="stt">leaf</span>.</p><p>Here is a longer example of the behavior of detectors, field access, and
constructors:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">data BTree:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| node(value :: Number, left :: BTree, right :: BTree)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| leaf(value :: Number)</span></p></td></tr><tr><td><p><span class="stt">where:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">a-btree = node(1, leaf(2), node(3, leaf(4), leaf(5)))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">BTree(a-btree) is true</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">BTree("not-a-tree") is false</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">BTree(leaf(5)) is true</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">is-leaf(leaf(5)) is true</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">is-leaf(a-btree) is false</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">is-leaf("not-a-tree") is false</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">is-node(leaf(5)) is false</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">is-node(a-btree) is true</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">is-node("not-a-tree") is false</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">a-btree.value is 1</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">a-btree.left.value is 2</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">a-btree.right.value is 3</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">a-btree.right.left.value is 4</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">a-btree.right.right.value is 4</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">end</span></p></td></tr></table></blockquote><p>A data definition can also define, for each instance as well as for the data
definition as a whole, a set of methods.  This is done with the keywords
<span class="stt">with:</span> and <span class="stt">sharing:</span>.  Methods defined on a variant via <span class="stt">with:</span> will
only be defined for instances of that variant, while methods defined on the
union of all the variants with <span class="stt">sharing:</span> are defined on all instances.  For
example:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">data BTree:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| node(value :: Number, left :: BTree, right :: BTree) with:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">size(self): 1 + self.left.size() + self.right.size() end</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">| leaf(value :: Number) with:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">size(self): 1 end,</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">increment(self): leaf(self.value + 1) end</span></p></td></tr><tr><td><p><span class="stt">sharing:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">values-equal(self, other):</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">self.value == other.value</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr><tr><td><p><span class="stt">where:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">a-btree = node(1, leaf(2), node(3, leaf(4), leaf(2)))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">a-btree.values-equal(leaf(1)) is true</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">leaf(1).values-equal(a-btree) is true</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">a-btree.size() is 3</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">leaf(0).size() is 1</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">leaf(1).increment() is leaf(2)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">a-btree.increment() # raises error: field increment not found.</span></p></td></tr><tr><td><p><span class="stt">end</span></p></td></tr></table></blockquote><h5>2.1.5.4<tt>&nbsp;</tt><a name="(part._s~3awhen-exp)"></a>When Expressions</h5><p>A when expression has a single test condition with a corresponding
block.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">when-expr: "when" binop-expr COLON block "end"</span></p></td></tr></table></blockquote><p>For example:</p><pre class="pyret-highlight"><p>when x == 42:
  print("answer")
end</p></pre><p>If the test condition is true, the block is evaluated. If the
test condition is false, nothing is done, and <span class="pyret-highlight"><span class="stt">nothing</span></span> is returned.</p><h5>2.1.5.5<tt>&nbsp;</tt><a name="(part._s~3avar-expr)"></a>Variable Declarations</h5><p>Variable declarations look like <a href="#%28part._s~3alet-expr%29" data-pltdoc="x">let bindings</a>, but
with an extra <span class="stt">var</span> keyword in the beginning:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">var-expr: "var" binding "=" expr</span></p></td></tr></table></blockquote><p>A <span class="stt">var</span> expression creates a new <span style="font-style: italic">assignable variable</span> in the current
scope, initialized to the value of the expression on the right of the <span class="stt">=</span>.
It can be accessed simply by using the variable name, which will always
evaluate to the last-assigned value of the variable.  <a href="#%28part._s~3aassign-expr%29" data-pltdoc="x">Assignment statements</a> can be used to update the value stored in an
assignable variable.</p><p>If the <span class="stt">binding</span> contains an annotation, the initial value is checked
against the annotation, and all <a href="#%28part._s~3aassign-expr%29" data-pltdoc="x">assignment
statements</a> to the variable check the annotation on the new value before
updating.</p><h5>2.1.5.6<tt>&nbsp;</tt><a name="(part._s~3aassign-expr)"></a>Assignment Statements</h5><p>Assignment statements have a name on the left, and an expression on the right
of <span class="stt">:=</span>:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">assign-expr: NAME ":=" binop-expr</span></p></td></tr></table></blockquote><p>If <span class="stt">NAME</span> is not declared in the same or an outer scope of the assignment
expression with a <span class="stt">var</span> declaration, the program fails with a static error.</p><p>At runtime, an assignment expression changes the value of the assignable
variable <span class="stt">NAME</span> to the result of the right-hand side expression.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="Blocks.html" title="backward to &quot;2.1.4 Blocks&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="s_forms.html" title="up to &quot;2.1 Language Constructs&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Expressions.html" title="forward to &quot;2.1.6 Expressions&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>