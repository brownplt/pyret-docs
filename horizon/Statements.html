<!doctype HTML>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="codemirror.js"></script>
<script src="runmode.js"></script>
<script src="pyret.js"></script>
<script src="hilite.js"></script>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>2.1.5&nbsp;Statements</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="codemirror.css" title="default"/><link rel="stylesheet" type="text/css" href="pyret.css" title="default"/><link rel="stylesheet" type="text/css" href="styles.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Pyret</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Getting_Started.html" class="tocviewlink" data-pltdoc="x">Getting Started</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Language_Concepts.html" class="tocviewselflink" data-pltdoc="x">Language Concepts</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="Builtins_and_Libraries.html" class="tocviewlink" data-pltdoc="x">Builtins and Libraries</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="Internals.html" class="tocviewlink" data-pltdoc="x">Internals</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>2&nbsp;</td><td><a href="Language_Concepts.html" class="tocviewlink" data-pltdoc="x">Language Concepts</a></td></tr></table><div class="tocviewsublist" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1&nbsp;</td><td><a href="s_forms.html" class="tocviewselflink" data-pltdoc="x">Language Constructs</a></td></tr><tr><td align="right">2.2&nbsp;</td><td><a href="testing.html" class="tocviewlink" data-pltdoc="x">Testing</a></td></tr><tr><td align="right">2.3&nbsp;</td><td><a href="equality.html" class="tocviewlink" data-pltdoc="x">equality</a></td></tr><tr><td align="right">2.4&nbsp;</td><td><a href="brands.html" class="tocviewlink" data-pltdoc="x">Brands</a></td></tr><tr><td align="right">2.5&nbsp;</td><td><a href="type-check.html" class="tocviewlink" data-pltdoc="x">Type Checking</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">&#9660;</a></td><td>2.1&nbsp;</td><td><a href="s_forms.html" class="tocviewlink" data-pltdoc="x">Language Constructs</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1.1&nbsp;</td><td><a href="s_program.html" class="tocviewlink" data-pltdoc="x">Programs</a></td></tr><tr><td align="right">2.1.2&nbsp;</td><td><a href="Import_Statements.html" class="tocviewlink" data-pltdoc="x">Import Statements</a></td></tr><tr><td align="right">2.1.3&nbsp;</td><td><a href="Provide_Statements.html" class="tocviewlink" data-pltdoc="x">Provide Statements</a></td></tr><tr><td align="right">2.1.4&nbsp;</td><td><a href="Blocks.html" class="tocviewlink" data-pltdoc="x">Blocks</a></td></tr><tr><td align="right">2.1.5&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Statements</a></td></tr><tr><td align="right">2.1.6&nbsp;</td><td><a href="Expressions.html" class="tocviewlink" data-pltdoc="x">Expressions</a></td></tr><tr><td align="right">2.1.7&nbsp;</td><td><a href="s_annotations.html" class="tocviewlink" data-pltdoc="x">Annotations</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_3&quot;);">&#9658;</a></td><td>2.1.5&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Statements</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_3"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1.5.1&nbsp;</td><td><a href="#%28part._s~3alet-expr%29" class="tocviewlink" data-pltdoc="x">Let Expressions</a></td></tr><tr><td align="right">2.1.5.2&nbsp;</td><td><a href="#%28part._s~3afun-expr%29" class="tocviewlink" data-pltdoc="x">Function Declaration Expressions</a></td></tr><tr><td align="right">2.1.5.3&nbsp;</td><td><a href="#%28part._s~3adata-expr%29" class="tocviewlink" data-pltdoc="x">Data Declarations</a></td></tr><tr><td align="right">2.1.5.4&nbsp;</td><td><a href="#%28part._s~3awhen-exp%29" class="tocviewlink" data-pltdoc="x">When Expressions</a></td></tr><tr><td align="right">2.1.5.5&nbsp;</td><td><a href="#%28part._s~3avar-expr%29" class="tocviewlink" data-pltdoc="x">Variable Declarations</a></td></tr><tr><td align="right">2.1.5.6&nbsp;</td><td><a href="#%28part._s~3aassign-expr%29" class="tocviewlink" data-pltdoc="x">Assignment Statements</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">2.1.5.1<tt>&nbsp;</tt></span><a href="#%28part._s~3alet-expr%29" class="tocsubseclink" data-pltdoc="x">Let Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.5.2<tt>&nbsp;</tt></span><a href="#%28part._s~3afun-expr%29" class="tocsubseclink" data-pltdoc="x">Function Declaration Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.5.3<tt>&nbsp;</tt></span><a href="#%28part._s~3adata-expr%29" class="tocsubseclink" data-pltdoc="x">Data Declarations</a></td></tr><tr><td><span class="tocsublinknumber">2.1.5.4<tt>&nbsp;</tt></span><a href="#%28part._s~3awhen-exp%29" class="tocsubseclink" data-pltdoc="x">When Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.5.5<tt>&nbsp;</tt></span><a href="#%28part._s~3avar-expr%29" class="tocsubseclink" data-pltdoc="x">Variable Declarations</a></td></tr><tr><td><span class="tocsublinknumber">2.1.5.6<tt>&nbsp;</tt></span><a href="#%28part._s~3aassign-expr%29" class="tocsubseclink" data-pltdoc="x">Assignment Statements</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="Blocks.html" title="backward to &quot;2.1.4 Blocks&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="s_forms.html" title="up to &quot;2.1 Language Constructs&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Expressions.html" title="forward to &quot;2.1.6 Expressions&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h5>2.1.5<tt>&nbsp;</tt><a name="(part._.Statements)"></a>Statements</h5><p>There are a number of forms that can only appear as statements in <span class="stt">block</span>s
and <span class="stt">provide</span> expressions:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._stmt)))"></a>&#8249;stmt&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._let-expr%29%29%29" data-pltdoc="x">&#8249;let-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._fun-expr%29%29%29" data-pltdoc="x">&#8249;fun-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._data-expr%29%29%29" data-pltdoc="x">&#8249;data-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._when-expr%29%29%29" data-pltdoc="x">&#8249;when-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._var-expr%29%29%29" data-pltdoc="x">&#8249;var-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._assign-expr%29%29%29" data-pltdoc="x">&#8249;assign-expr&#8250;</a><span class="bnf-meta"> | </span><a href="Expressions.html#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a></p></blockquote><h5>2.1.5.1<tt>&nbsp;</tt><a name="(part._s~3alet-expr)"></a>Let Expressions</h5><p>Let expressions are written with an equals sign:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._let-expr)))"></a>&#8249;let-expr&#8250;<span class="bnf-meta">:</span> <font class="badlink">&#8249;binding&#8250;</font> <span class="bnf-lit">=</span> <a href="Expressions.html#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a></p></blockquote><p>A let statement causes the name in the <span class="stt">binding</span> to be put in scope in the
current block, and upon evaluation sets the value to be the result of
evaluating the <span class="stt">binop-expr</span>.  The resulting binding cannot be changed via an
<span class="stt">assign-expr</span>, and cannot be shadowed by other bindings within the same or
nested scopes:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>x = 5
x := 10
# Error: x is not assignable
</p></pre></pre><pre class="pyret-block"><pre class="pyret-highlight"><p>x = 5
x = 10
# Error: x defined twice
</p></pre></pre><pre class="pyret-block"><pre class="pyret-highlight"><p>x = 5
fun f():
  x = 10
  x
end
# Error: can't use the name x in two nested scopes
</p></pre></pre><pre class="pyret-block"><pre class="pyret-highlight"><p>fun f():
  x = 10
  x
end
fun g():
  x = 22
  x
end
# Not an error: x is used in two scopes that are not nested</p></pre></pre><h5>2.1.5.2<tt>&nbsp;</tt><a name="(part._s~3afun-expr)"></a>Function Declaration Expressions</h5><p>Function declarations have a number of pieces:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._fun-expr)))"></a>&#8249;fun-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">fun</span> <span class="bnf-lit bnf-unknown">NAME</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._fun-header%29%29%29" data-pltdoc="x">&#8249;fun-header&#8250;</a> <span class="bnf-meta">[</span><span class="bnf-lit">block</span><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._doc-string%29%29%29" data-pltdoc="x">&#8249;doc-string&#8250;</a> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a> <a href="#%28elem._%28bnf-prod._%28.Pyret._where-clause%29%29%29" data-pltdoc="x">&#8249;where-clause&#8250;</a> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._fun-header)))"></a>&#8249;fun-header&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._ty-params%29%29%29" data-pltdoc="x">&#8249;ty-params&#8250;</a> <a href="#%28elem._%28bnf-prod._%28.Pyret._args%29%29%29" data-pltdoc="x">&#8249;args&#8250;</a> <a href="#%28elem._%28bnf-prod._%28.Pyret._return-ann%29%29%29" data-pltdoc="x">&#8249;return-ann&#8250;</a>
<a name="(elem._(bnf-prod._(.Pyret._ty-params)))"></a>&#8249;ty-params&#8250;<span class="bnf-meta">:</span> <span class="bnf-meta">[</span><span class="bnf-lit">&lt;</span> <span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._list-ty-param%29%29%29" data-pltdoc="x">&#8249;list-ty-param&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <span class="bnf-lit bnf-unknown">NAME</span> <span class="bnf-lit">&gt;</span><span class="bnf-meta">]</span>
<a name="(elem._(bnf-prod._(.Pyret._list-ty-param)))"></a>&#8249;list-ty-param&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">NAME</span> <span class="bnf-lit">,</span>
<a name="(elem._(bnf-prod._(.Pyret._args)))"></a>&#8249;args&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">(</span> <span class="bnf-meta">[</span><span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._list-arg-elt%29%29%29" data-pltdoc="x">&#8249;list-arg-elt&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <font class="badlink">&#8249;binding&#8250;</font><span class="bnf-meta">]</span> <span class="bnf-lit bnf-unknown">RPAREN</span>
<a name="(elem._(bnf-prod._(.Pyret._list-arg-elt)))"></a>&#8249;list-arg-elt&#8250;<span class="bnf-meta">:</span> <font class="badlink">&#8249;binding&#8250;</font> <span class="bnf-lit">,</span>
<a name="(elem._(bnf-prod._(.Pyret._return-ann)))"></a>&#8249;return-ann&#8250;<span class="bnf-meta">:</span> <span class="bnf-meta">[</span><span class="bnf-lit">-&gt;</span> <a href="s_annotations.html#%28elem._%28bnf-prod._%28.Pyret._ann%29%29%29" data-pltdoc="x">&#8249;ann&#8250;</a><span class="bnf-meta">]</span>
<a name="(elem._(bnf-prod._(.Pyret._doc-string)))"></a>&#8249;doc-string&#8250;<span class="bnf-meta">:</span> <span class="bnf-meta">[</span><span class="bnf-lit">doc:</span> <span class="bnf-lit bnf-unknown">STRING</span><span class="bnf-meta">]</span>
<a name="(elem._(bnf-prod._(.Pyret._where-clause)))"></a>&#8249;where-clause&#8250;<span class="bnf-meta">:</span> <span class="bnf-meta">[</span><span class="bnf-lit">where:</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a><span class="bnf-meta">]</span></p></blockquote><p>A function expression is syntactic sugar for a let and an anonymous function
expression for non-recursive case. The statement:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">"fun" NAME ty-params args return-ann ":"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">doc-string</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">block</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where-clause</span></p></td></tr><tr><td><p><span class="stt">"end"</span></p></td></tr></table></blockquote><p>is equivalent to</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">NAME "=" "lam" ty-params args return-ann ":"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">doc-string</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">block</span></p></td></tr><tr><td><p><span class="stt">"end"</span></p></td></tr></table></blockquote><p>With the <span class="stt">where-clause</span> registered in check mode.  Concretely:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>fun f(x, y):
  x + y
end</p></pre></pre><p>is equivalent to</p><pre class="pyret-block"><pre class="pyret-highlight"><p>f = lam(x, y):
  x + y
end</p></pre></pre><p>See the documentation for <span class="stt">lambda-exprs</span> for an explanation of arguments&rsquo;
and annotations&rsquo; behavior, as well as <span class="stt">doc-strings</span>.</p><h5>2.1.5.3<tt>&nbsp;</tt><a name="(part._s~3adata-expr)"></a>Data Declarations</h5><p>Data declarations define a number of related functions for creating and
manipulating a data type.  Their grammar is:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._data-expr)))"></a>&#8249;data-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">data</span> <span class="bnf-lit bnf-unknown">NAME</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._ty-params%29%29%29" data-pltdoc="x">&#8249;ty-params&#8250;</a> <span class="bnf-lit">:</span> <span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._data-variant%29%29%29" data-pltdoc="x">&#8249;data-variant&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._data-sharing%29%29%29" data-pltdoc="x">&#8249;data-sharing&#8250;</a> <a href="#%28elem._%28bnf-prod._%28.Pyret._where-clause%29%29%29" data-pltdoc="x">&#8249;where-clause&#8250;</a> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._data-variant)))"></a>&#8249;data-variant&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">|</span> <span class="bnf-lit bnf-unknown">NAME</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._variant-members%29%29%29" data-pltdoc="x">&#8249;variant-members&#8250;</a> <a href="#%28elem._%28bnf-prod._%28.Pyret._data-with%29%29%29" data-pltdoc="x">&#8249;data-with&#8250;</a><span class="bnf-meta"> | </span><span class="bnf-lit">|</span> <span class="bnf-lit bnf-unknown">NAME</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._data-with%29%29%29" data-pltdoc="x">&#8249;data-with&#8250;</a>
<a name="(elem._(bnf-prod._(.Pyret._variant-members)))"></a>&#8249;variant-members&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">(</span> <span class="bnf-meta">[</span><span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._list-variant-member%29%29%29" data-pltdoc="x">&#8249;list-variant-member&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._variant-member%29%29%29" data-pltdoc="x">&#8249;variant-member&#8250;</a><span class="bnf-meta">]</span> <span class="bnf-lit">)</span>
<a name="(elem._(bnf-prod._(.Pyret._list-variant-member)))"></a>&#8249;list-variant-member&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._variant-member%29%29%29" data-pltdoc="x">&#8249;variant-member&#8250;</a> <span class="bnf-lit">,</span>
<a name="(elem._(bnf-prod._(.Pyret._variant-member)))"></a>&#8249;variant-member&#8250;<span class="bnf-meta">:</span> <span class="bnf-meta">[</span><span class="bnf-lit">ref</span><span class="bnf-meta">]</span> <font class="badlink">&#8249;binding&#8250;</font>
<a name="(elem._(bnf-prod._(.Pyret._data-with)))"></a>&#8249;data-with&#8250;<span class="bnf-meta">:</span> <span class="bnf-meta">[</span><span class="bnf-lit">with:</span> <a href="Expressions.html#%28elem._%28bnf-prod._%28.Pyret._fields%29%29%29" data-pltdoc="x">&#8249;fields&#8250;</a><span class="bnf-meta">]</span>
<a name="(elem._(bnf-prod._(.Pyret._data-sharing)))"></a>&#8249;data-sharing&#8250;<span class="bnf-meta">:</span> <span class="bnf-meta">[</span><span class="bnf-lit">sharing:</span> <a href="Expressions.html#%28elem._%28bnf-prod._%28.Pyret._fields%29%29%29" data-pltdoc="x">&#8249;fields&#8250;</a><span class="bnf-meta">]</span></p></blockquote><p>A <span class="stt">data-expr</span> causes a number of new names to be bound in the scope of the
block it is defined in:</p><ul><li><p>The <span class="stt">NAME</span> of the data definition</p></li><li><p><span class="stt">NAME</span>, for each variant of the data definition</p></li><li><p><span class="stt">is-NAME</span>, for each variant of the data definition</p></li></ul><p>For example, in this data definition:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>data BTree:
  | node(value :: Number, left :: BTree, right :: BTree)
  | leaf(value :: Number)
end</p></pre></pre><p>These names are defined, with the given types:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>BTree :: (Any -&gt; Bool)
node :: (Number, BTree, BTree -&gt; BTree)
is-node :: (Any -&gt; Bool)
leaf :: (Number -&gt; BTree)
is-leaf :: (Any -&gt; Bool)</p></pre></pre><p>We call <span class="stt">node</span> and <span class="stt">leaf</span> the <span style="font-style: italic">constructors</span> of <span class="stt">BTree</span>, and they
construct values with the named fields.  They will refuse to create the value
if fields that don&rsquo;t match the annotations are given.  As with all annotations,
they are optional.  The constructed values can have their fields accessed with
<a href="Expressions.html#%28part._s~3adot-expr%29" data-pltdoc="x">dot expressions</a>.</p><p>The function <span class="stt">BTree</span> is a <span style="font-style: italic">detector</span> for values created from this data
definition, and can be used as an annotation to check for values created by the
constructors of <span class="stt">BTree</span>.  <span class="stt">BTree</span> returns true when provided values
created by <span class="stt">node</span> or <span class="stt">leaf</span>, but no others.</p><p>The functions <span class="stt">is-node</span> and <span class="stt">is-leaf</span> are detectors for the values
created by the individual constructors: <span class="stt">is-node</span> will only return <span class="stt">true</span>
for values created by calling <span class="stt">node</span>, and correspondingly for <span class="stt">leaf</span>.</p><p>Here is a longer example of the behavior of detectors, field access, and
constructors:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>data BTree:
  | node(value :: Number, left :: BTree, right :: BTree)
  | leaf(value :: Number)
where:
  a-btree = node(1, leaf(2), node(3, leaf(4), leaf(5)))

  BTree(a-btree) is true
  BTree("not-a-tree") is false
  BTree(leaf(5)) is true
  is-leaf(leaf(5)) is true
  is-leaf(a-btree) is false
  is-leaf("not-a-tree") is false
  is-node(leaf(5)) is false
  is-node(a-btree) is true
  is-node("not-a-tree") is false

  a-btree.value is 1
  a-btree.left.value is 2
  a-btree.right.value is 3
  a-btree.right.left.value is 4
  a-btree.right.right.value is 4

end</p></pre></pre><p>A data definition can also define, for each instance as well as for the data
definition as a whole, a set of methods.  This is done with the keywords
<span class="stt">with:</span> and <span class="stt">sharing:</span>.  Methods defined on a variant via <span class="stt">with:</span> will
only be defined for instances of that variant, while methods defined on the
union of all the variants with <span class="stt">sharing:</span> are defined on all instances.  For
example:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>data BTree:
  | node(value :: Number, left :: BTree, right :: BTree) with:
    method size(self): 1 + self.left.size() + self.right.size() end
  | leaf(value :: Number) with:
    method size(self): 1 end,
    method increment(self): leaf(self.value + 1) end
sharing:
  method values-equal(self, other):
    self.value == other.value
  end
where:
  a-btree = node(1, leaf(2), node(3, leaf(4), leaf(2)))
  a-btree.values-equal(leaf(1)) is true
  leaf(1).values-equal(a-btree) is true
  a-btree.size() is 3
  leaf(0).size() is 1
  leaf(1).increment() is leaf(2)
  a-btree.increment() # raises error: field increment not found.
end</p></pre></pre><h5>2.1.5.4<tt>&nbsp;</tt><a name="(part._s~3awhen-exp)"></a>When Expressions</h5><p>A when expression has a single test condition with a corresponding
block.</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._when-expr)))"></a>&#8249;when-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">when</span> <a href="Expressions.html#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a> <span class="bnf-meta">[</span><span class="bnf-lit">block</span><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a> <span class="bnf-lit">end</span></p></blockquote><p>For example:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>when x == 42:
  print("answer")
end</p></pre></pre><p>If the test condition is true, the block is evaluated. If the
test condition is false, nothing is done, and <span class="pyret-highlight"><span class="stt">nothing</span></span> is returned.</p><h5>2.1.5.5<tt>&nbsp;</tt><a name="(part._s~3avar-expr)"></a>Variable Declarations</h5><p>Variable declarations look like <a href="#%28part._s~3alet-expr%29" data-pltdoc="x">let bindings</a>, but
with an extra <span class="stt">var</span> keyword in the beginning:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._var-expr)))"></a>&#8249;var-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">var</span> <font class="badlink">&#8249;binding&#8250;</font> <span class="bnf-lit">=</span> <a href="Expressions.html#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></p></blockquote><p>A <span class="stt">var</span> expression creates a new <span style="font-style: italic">assignable variable</span> in the current
scope, initialized to the value of the expression on the right of the <span class="stt">=</span>.
It can be accessed simply by using the variable name, which will always
evaluate to the last-assigned value of the variable.  <a href="#%28part._s~3aassign-expr%29" data-pltdoc="x">Assignment statements</a> can be used to update the value stored in an
assignable variable.</p><p>If the <span class="stt">binding</span> contains an annotation, the initial value is checked
against the annotation, and all <a href="#%28part._s~3aassign-expr%29" data-pltdoc="x">assignment
statements</a> to the variable check the annotation on the new value before
updating.</p><h5>2.1.5.6<tt>&nbsp;</tt><a name="(part._s~3aassign-expr)"></a>Assignment Statements</h5><p>Assignment statements have a name on the left, and an expression on the right
of <span class="stt">:=</span>:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._assign-expr)))"></a>&#8249;assign-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">NAME</span> <span class="bnf-lit">:=</span> <a href="Expressions.html#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a></p></blockquote><p>If <span class="stt">NAME</span> is not declared in the same or an outer scope of the assignment
expression with a <span class="stt">var</span> declaration, the program fails with a static error.</p><p>At runtime, an assignment expression changes the value of the assignable
variable <span class="stt">NAME</span> to the result of the right-hand side expression.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="Blocks.html" title="backward to &quot;2.1.4 Blocks&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="s_forms.html" title="up to &quot;2.1 Language Constructs&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Expressions.html" title="forward to &quot;2.1.6 Expressions&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>