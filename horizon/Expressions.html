<!doctype HTML>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="codemirror.js"></script>
<script src="runmode.js"></script>
<script src="pyret.js"></script>
<script src="hilite.js"></script>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>2.1.6&nbsp;Expressions</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="codemirror.css" title="default"/><link rel="stylesheet" type="text/css" href="pyret.css" title="default"/><link rel="stylesheet" type="text/css" href="styles.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Pyret</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Getting_Started.html" class="tocviewlink" data-pltdoc="x">Getting Started</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Language_Concepts.html" class="tocviewselflink" data-pltdoc="x">Language Concepts</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="Builtins_and_Libraries.html" class="tocviewlink" data-pltdoc="x">Builtins and Libraries</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="Internals.html" class="tocviewlink" data-pltdoc="x">Internals</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>2&nbsp;</td><td><a href="Language_Concepts.html" class="tocviewlink" data-pltdoc="x">Language Concepts</a></td></tr></table><div class="tocviewsublist" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1&nbsp;</td><td><a href="s_forms.html" class="tocviewselflink" data-pltdoc="x">Language Constructs</a></td></tr><tr><td align="right">2.2&nbsp;</td><td><a href="testing.html" class="tocviewlink" data-pltdoc="x">Testing</a></td></tr><tr><td align="right">2.3&nbsp;</td><td><a href="equality.html" class="tocviewlink" data-pltdoc="x">equality</a></td></tr><tr><td align="right">2.4&nbsp;</td><td><a href="brands.html" class="tocviewlink" data-pltdoc="x">Brands</a></td></tr><tr><td align="right">2.5&nbsp;</td><td><a href="type-check.html" class="tocviewlink" data-pltdoc="x">Type Checking</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">&#9660;</a></td><td>2.1&nbsp;</td><td><a href="s_forms.html" class="tocviewlink" data-pltdoc="x">Language Constructs</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1.1&nbsp;</td><td><a href="s_program.html" class="tocviewlink" data-pltdoc="x">Programs</a></td></tr><tr><td align="right">2.1.2&nbsp;</td><td><a href="Import_Statements.html" class="tocviewlink" data-pltdoc="x">Import Statements</a></td></tr><tr><td align="right">2.1.3&nbsp;</td><td><a href="Provide_Statements.html" class="tocviewlink" data-pltdoc="x">Provide Statements</a></td></tr><tr><td align="right">2.1.4&nbsp;</td><td><a href="Blocks.html" class="tocviewlink" data-pltdoc="x">Blocks</a></td></tr><tr><td align="right">2.1.5&nbsp;</td><td><a href="Statements.html" class="tocviewlink" data-pltdoc="x">Statements</a></td></tr><tr><td align="right">2.1.6&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Expressions</a></td></tr><tr><td align="right">2.1.7&nbsp;</td><td><a href="s_annotations.html" class="tocviewlink" data-pltdoc="x">Annotations</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_3&quot;);">&#9658;</a></td><td>2.1.6&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Expressions</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_3"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1.6.1&nbsp;</td><td><a href="#%28part._s~3alam-expr%29" class="tocviewlink" data-pltdoc="x">Lambda Expressions</a></td></tr><tr><td align="right">2.1.6.2&nbsp;</td><td><a href="#%28part._s~3acurly-lam-expr%29" class="tocviewlink" data-pltdoc="x">Curly-<wbr></wbr>Brace Lambda Shorthand</a></td></tr><tr><td align="right">2.1.6.3&nbsp;</td><td><a href="#%28part._s~3aapp-expr%29" class="tocviewlink" data-pltdoc="x">Application Expressions</a></td></tr><tr><td align="right">2.1.6.4&nbsp;</td><td><a href="#%28part._s~3acurried-apply-expr%29" class="tocviewlink" data-pltdoc="x">Curried Application Expressions</a></td></tr><tr><td align="right">2.1.6.5&nbsp;</td><td><a href="#%28part._s~3acannonball-expr%29" class="tocviewlink" data-pltdoc="x">Chaining Application</a></td></tr><tr><td align="right">2.1.6.6&nbsp;</td><td><a href="#%28part._s~3abinop-expr%29" class="tocviewlink" data-pltdoc="x">Binary Operators</a></td></tr><tr><td align="right">2.1.6.7&nbsp;</td><td><a href="#%28part._s~3aobj-expr%29" class="tocviewlink" data-pltdoc="x">Object Expressions</a></td></tr><tr><td align="right">2.1.6.8&nbsp;</td><td><a href="#%28part._s~3adot-expr%29" class="tocviewlink" data-pltdoc="x">Dot Expressions</a></td></tr><tr><td align="right">2.1.6.9&nbsp;</td><td><a href="#%28part._s~3aextend-expr%29" class="tocviewlink" data-pltdoc="x">Extend Expressions</a></td></tr><tr><td align="right">2.1.6.10&nbsp;</td><td><a href="#%28part._s~3aif-expr%29" class="tocviewlink" data-pltdoc="x">If Expressions</a></td></tr><tr><td align="right">2.1.6.11&nbsp;</td><td><a href="#%28part._s~3aask-expr%29" class="tocviewlink" data-pltdoc="x">Ask Expressions</a></td></tr><tr><td align="right">2.1.6.12&nbsp;</td><td><a href="#%28part._s~3acases-expr%29" class="tocviewlink" data-pltdoc="x">Cases Expressions</a></td></tr><tr><td align="right">2.1.6.13&nbsp;</td><td><a href="#%28part._s~3afor-expr%29" class="tocviewlink" data-pltdoc="x">For Expressions</a></td></tr><tr><td align="right">2.1.6.14&nbsp;</td><td><a href="#%28part._s~3atemplate-expr%29" class="tocviewlink" data-pltdoc="x">Template (...) Expressions</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">2.1.6.1<tt>&nbsp;</tt></span><a href="#%28part._s~3alam-expr%29" class="tocsubseclink" data-pltdoc="x">Lambda Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.2<tt>&nbsp;</tt></span><a href="#%28part._s~3acurly-lam-expr%29" class="tocsubseclink" data-pltdoc="x">Curly-<wbr></wbr>Brace Lambda Shorthand</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.3<tt>&nbsp;</tt></span><a href="#%28part._s~3aapp-expr%29" class="tocsubseclink" data-pltdoc="x">Application Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.4<tt>&nbsp;</tt></span><a href="#%28part._s~3acurried-apply-expr%29" class="tocsubseclink" data-pltdoc="x">Curried Application Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.5<tt>&nbsp;</tt></span><a href="#%28part._s~3acannonball-expr%29" class="tocsubseclink" data-pltdoc="x">Chaining Application</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.6<tt>&nbsp;</tt></span><a href="#%28part._s~3abinop-expr%29" class="tocsubseclink" data-pltdoc="x">Binary Operators</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.7<tt>&nbsp;</tt></span><a href="#%28part._s~3aobj-expr%29" class="tocsubseclink" data-pltdoc="x">Object Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.8<tt>&nbsp;</tt></span><a href="#%28part._s~3adot-expr%29" class="tocsubseclink" data-pltdoc="x">Dot Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.9<tt>&nbsp;</tt></span><a href="#%28part._s~3aextend-expr%29" class="tocsubseclink" data-pltdoc="x">Extend Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.10<tt>&nbsp;</tt></span><a href="#%28part._s~3aif-expr%29" class="tocsubseclink" data-pltdoc="x">If Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.11<tt>&nbsp;</tt></span><a href="#%28part._s~3aask-expr%29" class="tocsubseclink" data-pltdoc="x">Ask Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.12<tt>&nbsp;</tt></span><a href="#%28part._s~3acases-expr%29" class="tocsubseclink" data-pltdoc="x">Cases Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.13<tt>&nbsp;</tt></span><a href="#%28part._s~3afor-expr%29" class="tocsubseclink" data-pltdoc="x">For Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.14<tt>&nbsp;</tt></span><a href="#%28part._s~3atemplate-expr%29" class="tocsubseclink" data-pltdoc="x">Template (...) Expressions</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="Statements.html" title="backward to &quot;2.1.5 Statements&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="s_forms.html" title="up to &quot;2.1 Language Constructs&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="s_annotations.html" title="forward to &quot;2.1.7 Annotations&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h5>2.1.6<tt>&nbsp;</tt><a name="(part._.Expressions)"></a>Expressions</h5><h5>2.1.6.1<tt>&nbsp;</tt><a name="(part._s~3alam-expr)"></a>Lambda Expressions</h5><p>The grammar for a lambda expression is:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">lambda-expr: "lam" ty-params [args] return-ann ":"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">doc-string</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">block</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"end"</span></p></td></tr><tr><td><p><span class="stt">ty-params:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">["&lt;" list-ty-param* NAME "&gt;"]</span></p></td></tr><tr><td><p><span class="stt">list-ty-param: NAME ","</span></p></td></tr><tr><td><p><span class="stt">args: (PARENSPACE|PARENNOSPACE) [list-arg-elt* binding] ")"</span></p></td></tr><tr><td><p><span class="stt">list-arg-elt: binding ","</span></p></td></tr><tr><td><p><span class="stt">return-ann: ["-&gt;" ann]</span></p></td></tr><tr><td><p><span class="stt">doc-string: ["doc:" STRING]</span></p></td></tr></table></blockquote><p>A lambda expression creates a function value that can be applied with
<a href="#%28part._s~3aapp-expr%29" data-pltdoc="x">application expressions</a>.  The arguments in <span class="stt">args</span>
are bound to their arguments as immutable identifiers as in a
<a href="Statements.html#%28part._s~3alet-expr%29" data-pltdoc="x">let expression</a>.</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-highlight"><p>check:
  f = lam(x, y): x - y end
  f(5, 3) is 2
end</p></pre></div></p></div><p>These identifiers follow the same rules of no shadowing and no assignment.</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-highlight"><p>x = 12
f = lam(x): x end  # ERROR: x shadows a previous definition
g = lam(y):
  y := 10   # ERROR: y is not a variable and cannot be assigned
  y + 1
end</p></pre></div></p></div><p>If the arguments have <a href="s_annotations.html" data-pltdoc="x">annotations</a> associated with
them, they are checked before the body of the function starts evaluating, in
order from left to right.  If an annotation fails, an exception is thrown.</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-highlight"><p>add1 = lam(x :: Number):
  x + 1
end
add1("not-a-number")
# Error: expected a Number and got "not-a-number"</p></pre></div></p></div><p>A lambda expression can have a <span style="font-style: italic">return</span> annotation as well, which is
checked before evaluating to the final value:</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-highlight"><p>add1 = lam(x) -&gt; Number:
  tostring(x) + "1"
end
add1(5)
# Error: expected a Number and got "51"</p></pre></div></p></div><p>Lambda expressions remember, or close over, the values of other identifiers
that are in scope when they are defined.  So, for example:</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-highlight"><p>check:
  x = 10
  f = lam(y): y + x end
  f(5) is 15
end</p></pre></div></p></div><h5>2.1.6.2<tt>&nbsp;</tt><a name="(part._s~3acurly-lam-expr)"></a>Curly-Brace Lambda Shorthand</h5><p>Lambda expressions can also be written with a curly-brace shorthand:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">curly-lambda-expr: "{" ty-params [args] return-ann ":"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">doc-string</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">block</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"}"</span></p></td></tr></table></blockquote><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-highlight"><p>check:
  x = 10
  f = {(y :: Number) -&gt; Number: x + y}
  f(5) is 15
end</p></pre></div></p></div><h5>2.1.6.3<tt>&nbsp;</tt><a name="(part._s~3aapp-expr)"></a>Application Expressions</h5><p>Function application expressions have the following grammar:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">app-expr: expr app-args</span></p></td></tr><tr><td><p><span class="stt">app-args: PARENNOSPACE [app-arg-elt* binop-expr] ")"</span></p></td></tr><tr><td><p><span class="stt">app-arg-elt: binop-expr ","</span></p></td></tr></table></blockquote><p>An application expression is an expression followed by a comma-separated list
of arguments enclosed in parentheses.  It first evaluates the arguments in
left-to-right order, then evaluates the function position.  If the function
position is a function value, the number of provided arguments is checked
against the number of arguments that the function expects.  If they match, the
arguments names are bound to the provided values.  If they don&rsquo;t, an exception
is thrown.</p><p>Note that there is <span style="font-style: italic">no space</span> allowed before the opening parenthesis of
the application.  If you make a mistake, Pyret will complain:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">f(1) # This is the function application expression f(1)</span></p></td></tr><tr><td><p><span class="stt">f (1) # This is the id-expr f, followed by the paren-expr (1)</span></p></td></tr><tr><td><p><span class="stt"># The second form yields a well-formedness error that there</span></p></td></tr><tr><td><p><span class="stt"># are two expressions on the same line</span></p></td></tr></table></blockquote><h5>2.1.6.4<tt>&nbsp;</tt><a name="(part._s~3acurried-apply-expr)"></a>Curried Application Expressions</h5><p>Suppose a function is defined with multiple arguments:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">fun f(v, w, x, y, z): ... end</span></p></td></tr></table></blockquote><p>Sometimes, it is particularly convenient to define a new function that
calls <span class="stt">f</span> with some arguments pre-specified:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">call-f-with-123 = lam(y, z): f(1, 2, 3, y, z) end</span></p></td></tr></table></blockquote><p>Pyret provides syntactic sugar to make writing such helper functions
easier:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">call-f-with-123 = f(1, 2, 3, _, _) # same as the lam expression above</span></p></td></tr></table></blockquote><p>Specifically, when Pyret code contains a function application some of
whose arguments are underscores, it constructs an lambda expression
with the same number of arguments as there were underscores in the
original expression, whose body is simply the original function
application, with the underscores replaced by the names of the
arguments to the anonymous function.</p><p>This syntactic sugar also works
with operators.  For example, the following are two ways to sum a list
of numbers:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">[list: 1, 2, 3, 4].foldl(lam(a, b): a + b end, 0)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">[list: 1, 2, 3, 4].foldl(_ + _, 0)</span></p></td></tr></table></blockquote><p>Likewise, the following are two ways to compare two lists for
equality:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">list.map_2(lam(x, y): x == y end, first-list, second-list)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">list.map_2(_ == _, first-list, second-list)</span></p></td></tr></table></blockquote><p>Note that there are some limitations to this syntactic sugar.  You
cannot use it with the <span class="stt">is</span> or <span class="stt">raises</span> expressions in
check blocks, since both test expressions and expected
outcomes are known when writing tests.  Also, note that the sugar is
applied only to one function application at a time.  As a result, the
following code:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">_ + _ + _</span></p></td></tr></table></blockquote><p>desugars to</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">lam(z):</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(fun (x, y): x + y end) + z</span></p></td></tr><tr><td><p><span class="stt">end</span></p></td></tr></table></blockquote><p>which is probably not what was intended.  You can still write the
intended expression manually:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">lam(x, y, z): x + y + z end</span></p></td></tr></table></blockquote><p>Pyret just does not provide syntactic sugar to help in this case
(or other more complicated ones).</p><h5>2.1.6.5<tt>&nbsp;</tt><a name="(part._s~3acannonball-expr)"></a>Chaining Application</h5><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">CARET: "^"</span></p></td></tr><tr><td><p><span class="stt">chain-app-expr: binop-expr CARET binop-expr</span></p></td></tr></table></blockquote><p>The expression <span class="pyret-highlight"><span class="stt">e1 ^ e2</span></span> is equivalent to <span class="pyret-highlight"><span class="stt">e2(e1)</span></span>.  It&rsquo;s just
another way of writing a function application to a single argument.</p><p>Sometimes, composing functions doesn&rsquo;t produce readable code.  For example, if
say we have a <span class="pyret-highlight"><span class="stt">Tree</span></span> datatype, and we have an <span class="pyret-highlight"><span class="stt">add</span></span> operation on
it, defined via a function.  To build up a tree with a series of adds, we&rsquo;d
write something like:</p><pre class="pyret-highlight"><p>t = add(add(add(add(empty-tree, 1), 2), 3), 4)</p></pre><p>Or maybe</p><pre class="pyret-highlight"><p>t1 = add(empty-tree, 1)
t2 = add(t1, 2)
t3 = add(t2, 3)
t  = add(t3, 4)</p></pre><p>If <span class="pyret-highlight"><span class="stt">add</span></span> were a method, we could write:</p><pre class="pyret-highlight"><p>t = empty-tree.add(1).add(2).add(3).add(4)</p></pre><p>which would be more readable, but since <span class="pyret-highlight"><span class="stt">add</span></span> is a function, this doesn&rsquo;t
work.</p><p>In this case, we can write instead:</p><pre class="pyret-highlight"><p>t = empty-tree ^ add(_, 1) ^ add(_, 2) ^ add(_, 3)</p></pre><p>This uses <a href="#%28part._s~3acurried-apply-expr%29" data-pltdoc="x">curried application</a> to create a
single argument function, and chaining application to apply it.  This can be
more readable across several lines of initialization as well, when compared to
composing &#8220;inside-out&#8221; or using several intermediate names:</p><pre class="pyret-highlight"><p>t = empty-tree
  ^ add(_, 1)
  ^ add(_, 2)
  ^ add(_, 3)
  # and so on</p></pre><h5>2.1.6.6<tt>&nbsp;</tt><a name="(part._s~3abinop-expr)"></a>Binary Operators</h5><p>There are a number of binary operators in Pyret.  A binary operator expression
is written by putting an operator between two other expressions, as in:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">binop-expr: binop-expr BINOP binop-expr</span></p></td></tr></table></blockquote><p>Each binary operator is syntactic sugar for a particular method or function
call.  The following table lists the operators, their intended use, and the
corresponding call:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">left + right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._plus(right)</span></p></td></tr><tr><td><p><span class="stt">left - right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._minus(right)</span></p></td></tr><tr><td><p><span class="stt">left * right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._times(right)</span></p></td></tr><tr><td><p><span class="stt">left / right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._divide(right)</span></p></td></tr><tr><td><p><span class="stt">left &lt;= right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._lessequal(right)</span></p></td></tr><tr><td><p><span class="stt">left &lt; right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._lessthan(right)</span></p></td></tr><tr><td><p><span class="stt">left &gt;= right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._greaterequal(right)</span></p></td></tr><tr><td><p><span class="stt">left &gt; right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._greaterthan(right)</span></p></td></tr></table></p><p>For the primitive strings and numbers, the operation happens internally.  For
all object values, the operator looks for the method appropriate method and
calls it.  The special names allow a form of operator overloading, and avoid
adding an extra concept beyond function and method calls to the core to
account for these binary operations.</p><h5>2.1.6.7<tt>&nbsp;</tt><a name="(part._s~3aobj-expr)"></a>Object Expressions</h5><p>Object expressions map field names to values:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">obj-expr: "{" fields "}" | "{" "}"</span></p></td></tr><tr><td><p><span class="stt">fields: list-field* field [","]</span></p></td></tr><tr><td><p><span class="stt">list-field: field ","</span></p></td></tr><tr><td><p><span class="stt">field: key ":" binop-expr</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| key args return-ann ":" doc-string block where-clause "end"</span></p></td></tr><tr><td><p><span class="stt">key: NAME</span></p></td></tr></table></blockquote><p>A comma-separated sequence of fields enclosed in <span class="stt">{}</span> creates an object; we
refer to the expression as an <span style="font-style: italic">object literal</span>.  There are two types of
fields: <span style="font-style: italic">data</span> fields and <span style="font-style: italic">method</span> fields.  A data field in an object
literal simply creates a field with that name on the resulting object, with its
value equal to the right-hand side of the field.  A method field</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">method key args return-ann ":" doc-string block where-clause "end"</span></p></td></tr></table></blockquote><p>is syntactic sugar for:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">key ":" "method" args return-ann ":" doc-string block where-clause "end"</span></p></td></tr></table></blockquote><p>That is, it&rsquo;s just special syntax for a data field that contains a method
value.</p><p>The fields are evaluated in the order they appear.  If the same field appears
more than once, it is a compile-time error.</p><h5>2.1.6.8<tt>&nbsp;</tt><a name="(part._s~3adot-expr)"></a>Dot Expressions</h5><p>A dot expression is any expression, followed by a dot and name:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">dot-expr: expr "." NAME</span></p></td></tr></table></blockquote><p>A dot expression evaluates the <span class="stt">expr</span> to a value <span class="stt">val</span>, and then does one
of three things:</p><ul><li><p>Raises an exception, if <span class="stt">NAME</span> is not a field of <span class="stt">expr</span></p></li><li><p>Evaluates to the value stored in <span class="stt">NAME</span>, if <span class="stt">NAME</span> is present and
not a method</p></li><li><p>If the <span class="stt">NAME</span> field is a method value, evaluates to a function that is
the <span style="font-style: italic">method binding</span> of the method value to <span class="stt">val</span>.  For a method</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">m = method(self, x): body end</span></p></td></tr></table></blockquote><p>The <span style="font-style: italic">method binding</span> of <span class="stt">m</span> to a value <span class="stt">v</span> is equivalent to:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">(lam(self): lam(x): body end end)(v)</span></p></td></tr></table></blockquote><p>What this detail means is that you can look up a method and it
automatically closes over the value on the left-hand side of the dot.  This
bound method can be freely used as a function.</p><p>For example:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">o = { m(self, x): self.y + x end, y: 22 }</span></p></td></tr><tr><td><p><span class="stt">check:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">the-m-method-closed-over-o = o.m</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">the-m-method-closed-over-o(5) is 27</span></p></td></tr><tr><td><p><span class="stt">end</span></p></td></tr></table></blockquote></li></ul><h5>2.1.6.9<tt>&nbsp;</tt><a name="(part._s~3aextend-expr)"></a>Extend Expressions</h5><p>The extend expression consists of an base expression and a list of fields to
extend it with:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">extend-expr: expr "." "{" fields "}"</span></p></td></tr></table></blockquote><p>The extend expression first evaluates <span class="stt">expr</span> to a value <span class="stt">val</span>, and then
creates a new object with all the fields of <span class="stt">val</span> and <span class="stt">fields</span>.  If a
field is present in both, the new field is used.</p><p>Examples:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">check:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">o = {x : "original-x", y: "original-y"}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">o2 = o.{x : "new-x", z : "new-z"}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">o2.x is "new-x"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">o2.y is "original-y"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">o2.z is "new-z"</span></p></td></tr><tr><td><p><span class="stt">end</span></p></td></tr></table></blockquote><h5>2.1.6.10<tt>&nbsp;</tt><a name="(part._s~3aif-expr)"></a>If Expressions</h5><p>An if expression has a number of test conditions and an optional else case.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">if-expr: IF binop-expr COLON block else-if* [ELSECOLON block] end</span></p></td></tr><tr><td><p><span class="stt">else-if: ELSEIF binop-expr COLON block</span></p></td></tr></table></blockquote><p>For example, this if expression has an "else:"</p><pre class="pyret-highlight"><p>if x == 0:
  1
else if x &gt; 0:
  x
else:
  x * -1
end</p></pre><p>This one does not:</p><pre class="pyret-highlight"><p>if x == 0:
  1
else if x &gt; 0:
  x
end</p></pre><p>Both are valid.  The conditions are tried in order, and the block corresponding
to the first one to return <span class="pyret-highlight"><span class="stt">true</span></span> is evaluated.  If no condition matches,
the else branch is evaluated if present.  If no condition matches and no else
branch is present, an error is thrown.  If a condition evaluates to a value
other than <span class="pyret-highlight"><span class="stt">true</span></span> or <span class="pyret-highlight"><span class="stt">false</span></span>, a runtime error is thrown.</p><h5>2.1.6.11<tt>&nbsp;</tt><a name="(part._s~3aask-expr)"></a>Ask Expressions</h5><p>An <span class="pyret-highlight"><span class="stt">ask</span></span> expression is a different way of writing an <span class="pyret-highlight"><span class="stt">if</span></span>
expression that can be easier to read in some cases.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">ask-expr: ASKCOLON ask-branch* [BAR OTHERWISECOLON block] end</span></p></td></tr><tr><td><p><span class="stt">ask-branch: BAR binop-expr THENCOLON block</span></p></td></tr></table></blockquote><p>This ask expression:</p><pre class="pyret-highlight"><p>ask:
  | x == 0 then: 1
  | x &gt; 0 then: x
  | otherwise: x * -1
end</p></pre><p>is equivalent to</p><pre class="pyret-highlight"><p>if x == 0:
  1
else if x &gt; 0:
  x
else:
  x * -1
end</p></pre><p>Similar to <span class="pyret-highlight"><span class="stt">if</span></span>, if an <span class="pyret-highlight"><span class="stt">otherwise:</span></span> branch isn&rsquo;t specified and no
branch matches, a runtime error results.</p><h5>2.1.6.12<tt>&nbsp;</tt><a name="(part._s~3acases-expr)"></a>Cases Expressions</h5><p>A cases expression consists of a datatype (in parentheses), an expression to
inspect (before the colon), and a number of branches.  It is intended to be
used in a structure parallel to a data definition.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">cases-expr: "cases" (PARENSPACE|PARENNOSPACE) check-ann ")" expr-target ":"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">cases-branch*</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">["|" "else" "=&gt;" block]</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"end"</span></p></td></tr><tr><td><p><span class="stt">cases-branch: "|" NAME [args] "=&gt;" block</span></p></td></tr></table></blockquote><p>The <span class="pyret-highlight"><span class="stt">check-ann</span></span> must be an annotation that refers to a <span class="stt">data</span>
declaration, like <a href="lists.html#%28part._lists_.List%29" data-pltdoc="x"><span class="stt">List</span></a>.  Then <span class="pyret-highlight"><span class="stt">expr-target</span></span> is
evaluated and checked against the given annotation.  If it has the right type,
the cases are then checked.</p><p>Cases should use the names of the variants of the given data type as the
<span class="stt">NAME</span>s of each branch.  In the branch that matches, the fields of the
variant are bound, in order, to the provided <span class="stt">args</span>, and the right-hand side
of the <span class="stt">=&gt;</span> is evaluated in that extended environment.  An exception results
if the wrong number of arguments are given.</p><p>An optional <span class="stt">else</span> clause can be provided, which is evaluated if no cases
match.  If no <span class="stt">else</span> clause is provided, a runtime error results.</p><p>For example, some cases expression on lists looks like:</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-highlight"><p>check:
  result = cases(List) [list: 1,2,3]:
    | empty =&gt; "empty"
    | link(f, r) =&gt; "link"
  end
  result is "link"

  result2 = cases(List) [list: 1,2,3]:
    | empty =&gt; "empty"
    | else =&gt; "else"
  end
  result2 is else

  result3 = cases(List) empty:
    | empty =&gt; "empty"
    | else =&gt; "else"
  end
  result3 is "empty"
end</p></pre></div></p></div><h5>2.1.6.13<tt>&nbsp;</tt><a name="(part._s~3afor-expr)"></a>For Expressions</h5><p>For expressions consist of the <span class="stt">for</span> keyword, followed by a list of
<span class="stt">binding from expr</span> clauses in parentheses, followed by a block:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">for-expr: "for" expr PARENNOSPACE [for-bind-elt* for-bind] ")" return-ann ":"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">block</span></p></td></tr><tr><td><p><span class="stt">"end"</span></p></td></tr><tr><td><p><span class="stt">for-bind-elt: for-bind ","</span></p></td></tr><tr><td><p><span class="stt">for-bind: binding "from" binop-expr</span></p></td></tr></table></blockquote><p>The for expression is just syntactic sugar for a
<a href="#%28part._s~3alam-expr%29" data-pltdoc="x"><span class="stt">lam-expr</span></a> and a <a href="#%28part._s~3aapp-expr%29" data-pltdoc="x"><span class="stt">app-expr</span></a>.  An expression</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">for fun-expr(arg1 :: ann1 from expr1, ...) -&gt; ann-return:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">block</span></p></td></tr><tr><td><p><span class="stt">end</span></p></td></tr></table></blockquote><p>is equivalent to:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">fun-expr(lam(arg1 :: ann1, ...) -&gt; ann-return: block end, expr1, ...)</span></p></td></tr></table></blockquote><p>Using a <span class="stt">for-expr</span> can be a more natural way to call, for example, list
iteration functions because it puts the identifier of the function and the
value it draws from closer to one another.  Use of <span class="stt">for-expr</span> is a matter of
style; here is an example that compares <span class="stt">fold</span> with and without <span class="stt">for</span>:</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-highlight"><p>for fold(sum from 0, number from [list: 1,2,3,4]):
  sum + number
end

fold(lam(sum, number): sum + number end, 0, [list: 1,2,3,4])</p></pre></div></p></div><h5>2.1.6.14<tt>&nbsp;</tt><a name="(part._s~3atemplate-expr)"></a>Template (...) Expressions</h5><p>A template expression is three dots in a row:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">template-expr: "..."</span></p></td></tr></table></blockquote><p>It is useful for a placeholder for other expressions in code-in-progress.  When
it is evaluated, it raises a runtime exception that indicates the expression it
is standing in for isn&rsquo;t yet implemented:</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-highlight"><p>fun list-sum(l :: List&lt;Number&gt;) -&gt; Number:
  cases(List&lt;Number&gt;) l:
    | empty =&gt; 0
    | link(first, rest) =&gt; first + ...
  end
end
check:
  list-sum(empty) is 0
  list-sum(link(1, empty)) raises "template-not-finished"
end</p></pre></div></p></div><p>This is handy for starting a function (especially one with many cases) with
some tests written and others to be completed.</p><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>These other positions for <span class="stt">...</span> may be included in the future.</p></blockquote></blockquote></blockquote></div><div class="SIntrapara">The <span class="stt">...</span> expression can only appear where <span style="font-style: italic">expressions</span> can appear.
So it is not allowed in binding positions or annotation positions.  These are
not allowed:</div></p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-highlight"><p>fun f(...): # parse error
  "todo"
end
x :: ... = 5 # parse error</p></pre></div></p></div><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="Statements.html" title="backward to &quot;2.1.5 Statements&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="s_forms.html" title="up to &quot;2.1 Language Constructs&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="s_annotations.html" title="forward to &quot;2.1.7 Annotations&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>