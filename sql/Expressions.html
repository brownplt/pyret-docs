<!doctype HTML>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="codemirror.js"></script>
<script src="runmode.js"></script>
<script src="pyret.js"></script>
<script src="hilite.js"></script>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>2.1.9&nbsp;Expressions</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="codemirror.css" title="default"/><link rel="stylesheet" type="text/css" href="pyret.css" title="default"/><link rel="stylesheet" type="text/css" href="styles.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Pyret</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Getting_Started.html" class="tocviewlink" data-pltdoc="x">Getting Started</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Language_Concepts.html" class="tocviewselflink" data-pltdoc="x">Language Concepts</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="Builtins_and_Libraries.html" class="tocviewlink" data-pltdoc="x">Builtins and Libraries</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="Internals.html" class="tocviewlink" data-pltdoc="x">Internals</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>2&nbsp;</td><td><a href="Language_Concepts.html" class="tocviewlink" data-pltdoc="x">Language Concepts</a></td></tr></table><div class="tocviewsublist" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1&nbsp;</td><td><a href="s_forms.html" class="tocviewselflink" data-pltdoc="x">Language Constructs</a></td></tr><tr><td align="right">2.2&nbsp;</td><td><a href="testing.html" class="tocviewlink" data-pltdoc="x">Testing</a></td></tr><tr><td align="right">2.3&nbsp;</td><td><a href="equality.html" class="tocviewlink" data-pltdoc="x">equality</a></td></tr><tr><td align="right">2.4&nbsp;</td><td><a href="brands.html" class="tocviewlink" data-pltdoc="x">Brands</a></td></tr><tr><td align="right">2.5&nbsp;</td><td><a href="type-check.html" class="tocviewlink" data-pltdoc="x">Type Checking</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">&#9660;</a></td><td>2.1&nbsp;</td><td><a href="s_forms.html" class="tocviewlink" data-pltdoc="x">Language Constructs</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1.1&nbsp;</td><td><a href="s_literals.html" class="tocviewlink" data-pltdoc="x">Primitives and Literals</a></td></tr><tr><td align="right">2.1.2&nbsp;</td><td><a href="s_program.html" class="tocviewlink" data-pltdoc="x">Programs</a></td></tr><tr><td align="right">2.1.3&nbsp;</td><td><a href="Import_Statements.html" class="tocviewlink" data-pltdoc="x">Import Statements</a></td></tr><tr><td align="right">2.1.4&nbsp;</td><td><a href="Provide_Statements.html" class="tocviewlink" data-pltdoc="x">Provide Statements</a></td></tr><tr><td align="right">2.1.5&nbsp;</td><td><a href="Bindings.html" class="tocviewlink" data-pltdoc="x">Bindings</a></td></tr><tr><td align="right">2.1.6&nbsp;</td><td><a href="Blocks.html" class="tocviewlink" data-pltdoc="x">Blocks</a></td></tr><tr><td align="right">2.1.7&nbsp;</td><td><a href="Declarations.html" class="tocviewlink" data-pltdoc="x">Declarations</a></td></tr><tr><td align="right">2.1.8&nbsp;</td><td><a href="Statements.html" class="tocviewlink" data-pltdoc="x">Statements</a></td></tr><tr><td align="right">2.1.9&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Expressions</a></td></tr><tr><td align="right">2.1.10&nbsp;</td><td><a href="s_annotations.html" class="tocviewlink" data-pltdoc="x">Annotations</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_3&quot;);">&#9658;</a></td><td>2.1.9&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Expressions</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_3"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1.9.1&nbsp;</td><td><a href="#%28part._s~3alam-expr%29" class="tocviewlink" data-pltdoc="x">Lambda Expressions</a></td></tr><tr><td align="right">2.1.9.2&nbsp;</td><td><a href="#%28part._s~3acurly-lam-expr%29" class="tocviewlink" data-pltdoc="x">Curly-<wbr></wbr>Brace Lambda Shorthand</a></td></tr><tr><td align="right">2.1.9.3&nbsp;</td><td><a href="#%28part._s~3amethod-expr%29" class="tocviewlink" data-pltdoc="x">Anonymous Method Expressions</a></td></tr><tr><td align="right">2.1.9.4&nbsp;</td><td><a href="#%28part._s~3aapp-expr%29" class="tocviewlink" data-pltdoc="x">Application Expressions</a></td></tr><tr><td align="right">2.1.9.5&nbsp;</td><td><a href="#%28part._s~3acurried-apply-expr%29" class="tocviewlink" data-pltdoc="x">Curried Application Expressions</a></td></tr><tr><td align="right">2.1.9.6&nbsp;</td><td><a href="#%28part._s~3acannonball-expr%29" class="tocviewlink" data-pltdoc="x">Chaining Application</a></td></tr><tr><td align="right">2.1.9.7&nbsp;</td><td><a href="#%28part._s~3abinop-expr%29" class="tocviewlink" data-pltdoc="x">Binary Operators</a></td></tr><tr><td align="right">2.1.9.8&nbsp;</td><td><a href="#%28part._s~3atuple-expr%29" class="tocviewlink" data-pltdoc="x">Tuple Expressions</a></td></tr><tr><td align="right">2.1.9.9&nbsp;</td><td><a href="#%28part._s~3atuple-get-expr%29" class="tocviewlink" data-pltdoc="x">Tuple Access Expressions</a></td></tr><tr><td align="right">2.1.9.10&nbsp;</td><td><a href="#%28part._s~3aobj-expr%29" class="tocviewlink" data-pltdoc="x">Object Expressions</a></td></tr><tr><td align="right">2.1.9.11&nbsp;</td><td><a href="#%28part._s~3adot-expr%29" class="tocviewlink" data-pltdoc="x">Dot Expressions</a></td></tr><tr><td align="right">2.1.9.12&nbsp;</td><td><a href="#%28part._s~3aextend-expr%29" class="tocviewlink" data-pltdoc="x">Extend Expressions</a></td></tr><tr><td align="right">2.1.9.13&nbsp;</td><td><a href="#%28part._s~3aif-expr%29" class="tocviewlink" data-pltdoc="x">If Expressions</a></td></tr><tr><td align="right">2.1.9.14&nbsp;</td><td><a href="#%28part._s~3aask-expr%29" class="tocviewlink" data-pltdoc="x">Ask Expressions</a></td></tr><tr><td align="right">2.1.9.15&nbsp;</td><td><a href="#%28part._s~3acases-expr%29" class="tocviewlink" data-pltdoc="x">Cases Expressions</a></td></tr><tr><td align="right">2.1.9.16&nbsp;</td><td><a href="#%28part._s~3afor-expr%29" class="tocviewlink" data-pltdoc="x">For Expressions</a></td></tr><tr><td align="right">2.1.9.17&nbsp;</td><td><a href="#%28part._s~3atemplate-expr%29" class="tocviewlink" data-pltdoc="x">Template (...) Expressions</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">2.1.9.1<tt>&nbsp;</tt></span><a href="#%28part._s~3alam-expr%29" class="tocsubseclink" data-pltdoc="x">Lambda Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.2<tt>&nbsp;</tt></span><a href="#%28part._s~3acurly-lam-expr%29" class="tocsubseclink" data-pltdoc="x">Curly-<wbr></wbr>Brace Lambda Shorthand</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.3<tt>&nbsp;</tt></span><a href="#%28part._s~3amethod-expr%29" class="tocsubseclink" data-pltdoc="x">Anonymous Method Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.4<tt>&nbsp;</tt></span><a href="#%28part._s~3aapp-expr%29" class="tocsubseclink" data-pltdoc="x">Application Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.5<tt>&nbsp;</tt></span><a href="#%28part._s~3acurried-apply-expr%29" class="tocsubseclink" data-pltdoc="x">Curried Application Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.6<tt>&nbsp;</tt></span><a href="#%28part._s~3acannonball-expr%29" class="tocsubseclink" data-pltdoc="x">Chaining Application</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.7<tt>&nbsp;</tt></span><a href="#%28part._s~3abinop-expr%29" class="tocsubseclink" data-pltdoc="x">Binary Operators</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.8<tt>&nbsp;</tt></span><a href="#%28part._s~3atuple-expr%29" class="tocsubseclink" data-pltdoc="x">Tuple Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.9<tt>&nbsp;</tt></span><a href="#%28part._s~3atuple-get-expr%29" class="tocsubseclink" data-pltdoc="x">Tuple Access Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.10<tt>&nbsp;</tt></span><a href="#%28part._s~3aobj-expr%29" class="tocsubseclink" data-pltdoc="x">Object Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.11<tt>&nbsp;</tt></span><a href="#%28part._s~3adot-expr%29" class="tocsubseclink" data-pltdoc="x">Dot Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.12<tt>&nbsp;</tt></span><a href="#%28part._s~3aextend-expr%29" class="tocsubseclink" data-pltdoc="x">Extend Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.13<tt>&nbsp;</tt></span><a href="#%28part._s~3aif-expr%29" class="tocsubseclink" data-pltdoc="x">If Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.14<tt>&nbsp;</tt></span><a href="#%28part._s~3aask-expr%29" class="tocsubseclink" data-pltdoc="x">Ask Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.15<tt>&nbsp;</tt></span><a href="#%28part._s~3acases-expr%29" class="tocsubseclink" data-pltdoc="x">Cases Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.16<tt>&nbsp;</tt></span><a href="#%28part._s~3afor-expr%29" class="tocsubseclink" data-pltdoc="x">For Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.9.17<tt>&nbsp;</tt></span><a href="#%28part._s~3atemplate-expr%29" class="tocsubseclink" data-pltdoc="x">Template (...) Expressions</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="Statements.html" title="backward to &quot;2.1.8 Statements&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="s_forms.html" title="up to &quot;2.1 Language Constructs&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="s_annotations.html" title="forward to &quot;2.1.10 Annotations&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h5>2.1.9<tt>&nbsp;</tt><a name="(part._.Expressions)"></a>Expressions</h5><p>The following are all the expression forms of Pyret:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._expr)))"></a>&#8249;expr&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._paren-expr%29%29%29" data-pltdoc="x">&#8249;paren-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._id-expr%29%29%29" data-pltdoc="x">&#8249;id-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._prim-expr%29%29%29" data-pltdoc="x">&#8249;prim-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._lam-expr%29%29%29" data-pltdoc="x">&#8249;lam-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._method-expr%29%29%29" data-pltdoc="x">&#8249;method-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._app-expr%29%29%29" data-pltdoc="x">&#8249;app-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._obj-expr%29%29%29" data-pltdoc="x">&#8249;obj-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._tuple-expr%29%29%29" data-pltdoc="x">&#8249;tuple-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._tuple-get%29%29%29" data-pltdoc="x">&#8249;tuple-get&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._dot-expr%29%29%29" data-pltdoc="x">&#8249;dot-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._template-expr%29%29%29" data-pltdoc="x">&#8249;template-expr&#8250;</a>
        <span class="bnf-meta"> | </span><font class="badlink">&#8249;get-bang-expr&#8250;</font><span class="bnf-meta"> | </span><font class="badlink">&#8249;update-expr&#8250;</font>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._extend-expr%29%29%29" data-pltdoc="x">&#8249;extend-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._if-expr%29%29%29" data-pltdoc="x">&#8249;if-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._ask-expr%29%29%29" data-pltdoc="x">&#8249;ask-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._cases-expr%29%29%29" data-pltdoc="x">&#8249;cases-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._for-expr%29%29%29" data-pltdoc="x">&#8249;for-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._user-block-expr%29%29%29" data-pltdoc="x">&#8249;user-block-expr&#8250;</a><span class="bnf-meta"> | </span><font class="badlink">&#8249;inst-expr&#8250;</font>
        <span class="bnf-meta"> | </span><font class="badlink">&#8249;multi-let-expr&#8250;</font><span class="bnf-meta"> | </span><font class="badlink">&#8249;letrec-expr&#8250;</font>
        <span class="bnf-meta"> | </span><font class="badlink">&#8249;type-let-expr&#8250;</font>
        <span class="bnf-meta"> | </span><font class="badlink">&#8249;construct-expr&#8250;</font>
<a name="(elem._(bnf-prod._(.Pyret._paren-expr)))"></a>&#8249;paren-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">(</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-lit">)</span>
<a name="(elem._(bnf-prod._(.Pyret._id-expr)))"></a>&#8249;id-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">NAME</span>
<a name="(elem._(bnf-prod._(.Pyret._prim-expr)))"></a>&#8249;prim-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">NUMBER</span><span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">RATIONAL</span><span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">BOOLEAN</span><span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">STRING</span></p></blockquote><h5>2.1.9.1<tt>&nbsp;</tt><a name="(part._s~3alam-expr)"></a>Lambda Expressions</h5><p>The grammar for a lambda expression is:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._lam-expr)))"></a>&#8249;lam-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">lam</span> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._fun-header%29%29%29" data-pltdoc="x">&#8249;fun-header&#8250;</a> <span class="bnf-meta">[</span><span class="bnf-lit">block</span><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._doc-string%29%29%29" data-pltdoc="x">&#8249;doc-string&#8250;</a> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._where-clause%29%29%29" data-pltdoc="x">&#8249;where-clause&#8250;</a> <span class="bnf-lit">end</span></p></blockquote><p>A lambda expression creates a function value that can be applied with
<a href="#%28part._s~3aapp-expr%29" data-pltdoc="x">application expressions</a>.  The arguments in <span class="stt">args</span>
are bound to their arguments as immutable identifiers as in a
<a href="Declarations.html#%28part._s~3alet-decl%29" data-pltdoc="x">let expression</a>.</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>check:
  f = lam(x, y): x - y end
  f(5, 3) is 2
end

check:
  f = lam({x;y}): x - y end
  f({5;3}) is 2
end</p></pre></pre></div></p></div><p>These identifiers follow the same rules of no shadowing and no assignment.</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>x = 12
f = lam(x): x end  # ERROR: x shadows a previous definition
g = lam(y):
  y := 10   # ERROR: y is not a variable and cannot be assigned
  y + 1
end</p></pre></pre></div></p></div><p>If the arguments have <a href="s_annotations.html" data-pltdoc="x">annotations</a> associated with
them, they are checked before the body of the function starts evaluating, in
order from left to right.  If an annotation fails, an exception is thrown.</p><pre class="pyret-block"><pre class="pyret-highlight"><p>add1 = lam(x :: Number):
  x + 1
end
add1("not-a-number")
# Error: expected a Number and got "not-a-number"</p></pre></pre><p>A lambda expression can have a <span style="font-style: italic">return</span> annotation as well, which is
checked before evaluating to the final value:</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>add1 = lam(x) -&gt; Number:
  tostring(x) + "1"
end
add1(5)
# Error: expected a Number and got "51"</p></pre></pre></div></p></div><p>Lambda expressions remember, or close over, the values of other identifiers
that are in scope when they are defined.  So, for example:</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>check:
  x = 10
  f = lam(y): y + x end
  f(5) is 15
end</p></pre></pre></div></p></div><h5>2.1.9.2<tt>&nbsp;</tt><a name="(part._s~3acurly-lam-expr)"></a>Curly-Brace Lambda Shorthand</h5><p>Lambda expressions can also be written with a curly-brace shorthand:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">curly-lambda-expr: "{" ty-params [args] return-ann ":"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">doc-string</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">block</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"}"</span></p></td></tr></table></blockquote><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>check:
  x = 10
  f = {(y :: Number) -&gt; Number: x + y}
  f(5) is 15
end</p></pre></pre></div></p></div><h5>2.1.9.3<tt>&nbsp;</tt><a name="(part._s~3amethod-expr)"></a>Anonymous Method Expressions</h5><p>An anonymous method expression looks much like an anonymous function (defined
with <span class="pyret-highlight"><span class="stt">lam</span></span>):</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._method-expr)))"></a>&#8249;method-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">method</span> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._fun-header%29%29%29" data-pltdoc="x">&#8249;fun-header&#8250;</a> <span class="bnf-meta">[</span><span class="bnf-lit">block</span><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._doc-string%29%29%29" data-pltdoc="x">&#8249;doc-string&#8250;</a> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._where-clause%29%29%29" data-pltdoc="x">&#8249;where-clause&#8250;</a> <span class="bnf-lit">end</span></p></blockquote><p>All the same rules for bindings, including annotations and shadowing, apply the
same to <a href="#%28elem._%28bnf-prod._%28.Pyret._method-expr%29%29%29" data-pltdoc="x">&#8249;method-expr&#8250;</a>s as they do to <a href="#%28elem._%28bnf-prod._%28.Pyret._lam-expr%29%29%29" data-pltdoc="x">&#8249;lam-expr&#8250;</a>s.</p><p>It is a well-formedness error for a method to have no arguments.</p><p>At runtime, a <a href="#%28elem._%28bnf-prod._%28.Pyret._method-expr%29%29%29" data-pltdoc="x">&#8249;method-expr&#8250;</a> evaluates to a method value.  Method values
cannot be applied directly:</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>check:
  m = method(self): self end
  m(5) raises "non-function"
end</p></pre></pre></div></p></div><p>Instead, methods must be included as object fields, where they can then be
bound and invoked.  A method value can be used in multiple objects:</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>check:
  m = method(self): self.x end
  o = { a-method-name: m, x: 20 }
  o2 = { a-method-name: m, x: 30 }
  o.m() is 20
  o2.m() is 30
end</p></pre></pre></div></p></div><h5>2.1.9.4<tt>&nbsp;</tt><a name="(part._s~3aapp-expr)"></a>Application Expressions</h5><p>Function application expressions have the following grammar:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._app-expr)))"></a>&#8249;app-expr&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <a href="#%28elem._%28bnf-prod._%28.Pyret._app-args%29%29%29" data-pltdoc="x">&#8249;app-args&#8250;</a>
<a name="(elem._(bnf-prod._(.Pyret._app-args)))"></a>&#8249;app-args&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">(</span> <span class="bnf-meta">[</span><span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._app-arg-elt%29%29%29" data-pltdoc="x">&#8249;app-arg-elt&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a><span class="bnf-meta">]</span> <span class="bnf-lit">)</span>
<a name="(elem._(bnf-prod._(.Pyret._app-arg-elt)))"></a>&#8249;app-arg-elt&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a> <span class="bnf-lit">,</span></p></blockquote><p>An application expression is an expression followed by a comma-separated list
of arguments enclosed in parentheses.  It first evaluates the arguments in
left-to-right order, then evaluates the function position.  If the function
position is a function value, the number of provided arguments is checked
against the number of arguments that the function expects.  If they match, the
arguments names are bound to the provided values.  If they don&rsquo;t, an exception
is thrown.</p><p>Note that there is <span style="font-style: italic">no space</span> allowed before the opening parenthesis of
the application.  If you make a mistake, Pyret will complain:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>f(1) # This is the function application expression f(1)
f (1) # This is the id-expr f, followed by the paren-expr (1)
# The second form yields a well-formedness error that there
# are two expressions on the same line</p></pre></pre><h5>2.1.9.5<tt>&nbsp;</tt><a name="(part._s~3acurried-apply-expr)"></a>Curried Application Expressions</h5><p>Suppose a function is defined with multiple arguments:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>fun f(v, w, x, y, z): ... end</p></pre></pre><p>Sometimes, it is particularly convenient to define a new function that
calls <span class="stt">f</span> with some arguments pre-specified:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>call-f-with-123 = lam(y, z): f(1, 2, 3, y, z) end</p></pre></pre><p>Pyret provides syntactic sugar to make writing such helper functions
easier:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>call-f-with-123 = f(1, 2, 3, _, _) # same as the fun expression above</p></pre></pre><p>Specifically, when Pyret code contains a function application some of
whose arguments are underscores, it constructs an lambda expression
with the same number of arguments as there were underscores in the
original expression, whose body is simply the original function
application, with the underscores replaced by the names of the
arguments to the anonymous function.</p><p>This syntactic sugar also works
with operators.  For example, the following are two ways to sum a list
of numbers:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>[list: 1, 2, 3, 4].foldl(lam(a, b): a + b end, 0)

[list: 1, 2, 3, 4].foldl(_ + _, 0)</p></pre></pre><p>Likewise, the following are two ways to compare two lists for
equality:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>list.map_2(lam(x, y): x == y end, first-list, second-list)

list.map_2(_ == _, first-list, second-list)</p></pre></pre><p>Note that there are some limitations to this syntactic sugar.  You
cannot use it with the <span class="stt">is</span> or <span class="stt">raises</span> expressions in
check blocks, since both test expressions and expected
outcomes are known when writing tests.  Also, note that the sugar is
applied only to one function application at a time.  As a result, the
following code:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>_ + _ + _</p></pre></pre><p>desugars to</p><pre class="pyret-block"><pre class="pyret-highlight"><p>lam(z):
  (lam(x, y): x + y end) + z
end</p></pre></pre><p>which is probably not what was intended.  You can still write the
intended expression manually:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>lam(x, y, z): x + y + z end</p></pre></pre><p>Pyret just does not provide syntactic sugar to help in this case
(or other more complicated ones).</p><h5>2.1.9.6<tt>&nbsp;</tt><a name="(part._s~3acannonball-expr)"></a>Chaining Application</h5><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._chain-app-expr)))"></a>&#8249;chain-app-expr&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a> <span class="bnf-lit">^</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a></p></blockquote><p>The expression <span class="pyret-highlight"><span class="stt">e1 ^ e2</span></span> is equivalent to <span class="pyret-highlight"><span class="stt">e2(e1)</span></span>.  It&rsquo;s just
another way of writing a function application to a single argument.</p><p>Sometimes, composing functions doesn&rsquo;t produce readable code.  For example, if
say we have a <span class="pyret-highlight"><span class="stt">Tree</span></span> datatype, and we have an <span class="pyret-highlight"><span class="stt">add</span></span> operation on
it, defined via a function.  To build up a tree with a series of adds, we&rsquo;d
write something like:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>t = add(add(add(add(empty-tree, 1), 2), 3), 4)</p></pre></pre><p>Or maybe</p><pre class="pyret-block"><pre class="pyret-highlight"><p>t1 = add(empty-tree, 1)
t2 = add(t1, 2)
t3 = add(t2, 3)
t  = add(t3, 4)</p></pre></pre><p>If <span class="pyret-highlight"><span class="stt">add</span></span> were a method, we could write:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>t = empty-tree.add(1).add(2).add(3).add(4)</p></pre></pre><p>which would be more readable, but since <span class="pyret-highlight"><span class="stt">add</span></span> is a function, this doesn&rsquo;t
work.</p><p>In this case, we can write instead:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>t = empty-tree ^ add(_, 1) ^ add(_, 2) ^ add(_, 3)</p></pre></pre><p>This uses <a href="#%28part._s~3acurried-apply-expr%29" data-pltdoc="x">curried application</a> to create a
single argument function, and chaining application to apply it.  This can be
more readable across several lines of initialization as well, when compared to
composing &#8220;inside-out&#8221; or using several intermediate names:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>t = empty-tree
  ^ add(_, 1)
  ^ add(_, 2)
  ^ add(_, 3)
  # and so on</p></pre></pre><h5>2.1.9.7<tt>&nbsp;</tt><a name="(part._s~3abinop-expr)"></a>Binary Operators</h5><p>There are a number of binary operators in Pyret.  A binary operator expression
is a series of expressions joined by binary operators. An expression itself
is also a binary operator expression.</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._binop-expr)))"></a>&#8249;binop-expr&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-meta">(</span><span class="bnf-lit bnf-unknown">BINOP</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span></p></blockquote><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>The <span class="pyret-highlight"><span class="stt">==</span></span> and <span class="pyret-highlight"><span class="stt">=~</span></span> operators also call methods, but are
somewhat more complex.  They are documented in detail in <a href="equality.html" data-pltdoc="x">equality</a>.</p></blockquote></blockquote></blockquote></div><div class="SIntrapara">Each binary operator is syntactic sugar for a particular method or function
call.  The following table lists the operators, their intended use, and the
corresponding call:</div></p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">left + right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._plus(right)</span></p></td></tr><tr><td><p><span class="stt">left - right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._minus(right)</span></p></td></tr><tr><td><p><span class="stt">left * right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._times(right)</span></p></td></tr><tr><td><p><span class="stt">left / right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._divide(right)</span></p></td></tr><tr><td><p><span class="stt">left &lt;= right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._lessequal(right)</span></p></td></tr><tr><td><p><span class="stt">left &lt; right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._lessthan(right)</span></p></td></tr><tr><td><p><span class="stt">left &gt;= right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._greaterequal(right)</span></p></td></tr><tr><td><p><span class="stt">left &gt; right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._greaterthan(right)</span></p></td></tr></table></p><p>For the primitive strings and numbers, the operation happens internally.  For
all object or data values, the operator looks for the method appropriate method
and calls it.</p><h5>2.1.9.8<tt>&nbsp;</tt><a name="(part._s~3atuple-expr)"></a>Tuple Expressions</h5><p>Tuples are an immutable, fixed-length collection of expressions indexed by non-negative integers:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._tuple-expr)))"></a>&#8249;tuple-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">{</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._tuple-fields%29%29%29" data-pltdoc="x">&#8249;tuple-fields&#8250;</a> <span class="bnf-lit">}</span>
<a name="(elem._(bnf-prod._(.Pyret._tuple-fields)))"></a>&#8249;tuple-fields&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a> <span class="bnf-meta">(</span><span class="bnf-lit">;</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <span class="bnf-meta">[</span><span class="bnf-lit">;</span><span class="bnf-meta">]</span></p></blockquote><p>A semicolon-separated sequence of fields enclosed in <span class="stt">{}</span> creates a tuple.</p><h5>2.1.9.9<tt>&nbsp;</tt><a name="(part._s~3atuple-get-expr)"></a>Tuple Access Expressions</h5><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._tuple-get)))"></a>&#8249;tuple-get&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-lit">.</span> <span class="bnf-lit">{</span> <span class="bnf-lit bnf-unknown">NUMBER</span> <span class="bnf-lit">}</span></p></blockquote><p>A tuple-get expression evaluates the <span class="stt">expr</span> to a value <span class="stt">val</span>, and then
does one of three things:</p><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>A static well-formedness error is raised if the index is
negative</p></blockquote></blockquote></blockquote></div><div class="SIntrapara"><ul><li><p>Raises an exception, if <span class="stt">expr</span> is not a tuple</p></li><li><p>Raises an exception, if <span class="stt">NUMBER</span> is equal to or greater than the length of the given tuple</p></li><li><p>Evaluates the expression, returning the <span class="stt">val</span> at the given index.  The first index is <span class="pyret-highlight"><span class="stt">0</span></span></p></li></ul></div></p><p>For example:</p><pre class="pyret-block"><pre class="pyret-highlight good-ex"><p>check:
  t = {"a";"b";true}
  t.{0} is "a"
  t.{1} is "b"
  t.{2} is true
end</p></pre></pre><p>Note that the index is restricted <span style="font-style: italic">syntactically</span> to being a number.  So this program is a parse error:</p><pre class="pyret-block"><pre class="pyret-highlight bad-ex"><p>t = {"a";"b";"c"}
t.{1 + 1}</p></pre></pre><p>This restriction ensures that tuple access is typable.</p><h5>2.1.9.10<tt>&nbsp;</tt><a name="(part._s~3aobj-expr)"></a>Object Expressions</h5><p>Object expressions map field names to values:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._obj-expr)))"></a>&#8249;obj-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">{</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._fields%29%29%29" data-pltdoc="x">&#8249;fields&#8250;</a> <span class="bnf-lit">}</span><span class="bnf-meta"> | </span><span class="bnf-lit">{</span> <span class="bnf-lit">}</span>
<a name="(elem._(bnf-prod._(.Pyret._fields)))"></a>&#8249;fields&#8250;<span class="bnf-meta">:</span> <span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._list-field%29%29%29" data-pltdoc="x">&#8249;list-field&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._field%29%29%29" data-pltdoc="x">&#8249;field&#8250;</a> <span class="bnf-meta">[</span><span class="bnf-lit">,</span><span class="bnf-meta">]</span>
<a name="(elem._(bnf-prod._(.Pyret._list-field)))"></a>&#8249;list-field&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._field%29%29%29" data-pltdoc="x">&#8249;field&#8250;</a> <span class="bnf-lit">,</span>
<a name="(elem._(bnf-prod._(.Pyret._field)))"></a>&#8249;field&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._key%29%29%29" data-pltdoc="x">&#8249;key&#8250;</a> <span class="bnf-lit">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a>
          <span class="bnf-meta"> | </span><span class="bnf-lit">method</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._key%29%29%29" data-pltdoc="x">&#8249;key&#8250;</a> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._fun-header%29%29%29" data-pltdoc="x">&#8249;fun-header&#8250;</a> <span class="bnf-meta">[</span><span class="bnf-lit">block</span><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._doc-string%29%29%29" data-pltdoc="x">&#8249;doc-string&#8250;</a> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._where-clause%29%29%29" data-pltdoc="x">&#8249;where-clause&#8250;</a> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._key)))"></a>&#8249;key&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">NAME</span></p></blockquote><p>A comma-separated sequence of fields enclosed in <span class="stt">{}</span> creates an object; we
refer to the expression as an <span style="font-style: italic">object literal</span>.  There are two types of
fields: <span style="font-style: italic">data</span> fields and <span style="font-style: italic">method</span> fields.  A data field in an object
literal simply creates a field with that name on the resulting object, with its
value equal to the right-hand side of the field. A method field</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">"method" key fun-header ":" doc-string block where-clause "end"</span></p></td></tr></table></blockquote><p>is syntactic sugar for:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">key ":" "method" fun-header ":" doc-string block where-clause "end"</span></p></td></tr></table></blockquote><p>That is, it&rsquo;s just special syntax for a data field that contains a method
value.</p><p>The fields are evaluated in the order they appear.  If the same field appears
more than once, it is a compile-time error.</p><h5>2.1.9.11<tt>&nbsp;</tt><a name="(part._s~3adot-expr)"></a>Dot Expressions</h5><p>A dot expression is any expression, followed by a dot and name:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._dot-expr)))"></a>&#8249;dot-expr&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-lit">.</span> <span class="bnf-lit bnf-unknown">NAME</span></p></blockquote><p>A dot expression evaluates the <span class="stt">expr</span> to a value <span class="stt">val</span>, and then does one
of three things:</p><ul><li><p>Raises an exception, if <span class="stt">NAME</span> is not a field of <span class="stt">expr</span></p></li><li><p>Evaluates to the value stored in <span class="stt">NAME</span>, if <span class="stt">NAME</span> is present and
not a method</p></li><li><p>If the <span class="stt">NAME</span> field is a method value, evaluates to a function that is
the <span style="font-style: italic">method binding</span> of the method value to <span class="stt">val</span>.  For a method</p><pre class="pyret-block"><pre class="pyret-highlight"><p>m = method(self, x): body end</p></pre></pre><p>The <span style="font-style: italic">method binding</span> of <span class="stt">m</span> to a value <span class="stt">v</span> is equivalent to:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>(lam(self): lam(x): body end end)(v)</p></pre></pre><p>What this detail means is that you can look up a method and it
automatically closes over the value on the left-hand side of the dot.  This
bound method can be freely used as a function.</p><p>For example:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>o = { method m(self, x): self.y + x end, y: 22 }
check:
  the-m-method-closed-over-o = o.m
  the-m-method-closed-over-o(5) is 27
end</p></pre></pre></li></ul><h5>2.1.9.12<tt>&nbsp;</tt><a name="(part._s~3aextend-expr)"></a>Extend Expressions</h5><p>The extend expression consists of an base expression and a list of fields to
extend it with:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._extend-expr)))"></a>&#8249;extend-expr&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-lit">.</span> <span class="bnf-lit">{</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._fields%29%29%29" data-pltdoc="x">&#8249;fields&#8250;</a> <span class="bnf-lit">}</span></p></blockquote><p>The extend expression first evaluates <span class="stt">expr</span> to a value <span class="stt">val</span>, and then
creates a new object with all the fields of <span class="stt">val</span> and <span class="stt">fields</span>.  If a
field is present in both, the new field is used.</p><p>Examples:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>check:
  o = {x : "original-x", y: "original-y"}
  o2 = o.{x : "new-x", z : "new-z"}
  o2.x is "new-x"
  o2.y is "original-y"
  o2.z is "new-z"
end</p></pre></pre><h5>2.1.9.13<tt>&nbsp;</tt><a name="(part._s~3aif-expr)"></a>If Expressions</h5><p>An if expression has a number of test conditions and an optional else case.</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._if-expr)))"></a>&#8249;if-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">if</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a> <span class="bnf-meta">[</span><span class="bnf-lit">block</span><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a> <span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._else-if%29%29%29" data-pltdoc="x">&#8249;else-if&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <span class="bnf-meta">[</span><span class="bnf-lit">else:</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a><span class="bnf-meta">]</span> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._else-if)))"></a>&#8249;else-if&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">else if</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a> <span class="bnf-lit">:</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a></p></blockquote><p>For example, this if expression has an "else:"</p><pre class="pyret-block"><pre class="pyret-highlight"><p>if x == 0:
  1
else if x &gt; 0:
  x
else:
  x * -1
end</p></pre></pre><p>This one does not:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>if x == 0:
  1
else if x &gt; 0:
  x
end</p></pre></pre><p>Both are valid.  The conditions are tried in order, and the block corresponding
to the first one to return <span class="pyret-highlight"><span class="stt">true</span></span> is evaluated.  If no condition matches,
the else branch is evaluated if present.  If no condition matches and no else
branch is present, an error is thrown.  If a condition evaluates to a value
other than <span class="pyret-highlight"><span class="stt">true</span></span> or <span class="pyret-highlight"><span class="stt">false</span></span>, a runtime error is thrown.</p><h5>2.1.9.14<tt>&nbsp;</tt><a name="(part._s~3aask-expr)"></a>Ask Expressions</h5><p>An <span class="pyret-highlight"><span class="stt">ask</span></span> expression is a different way of writing an <span class="pyret-highlight"><span class="stt">if</span></span>
expression that can be easier to read in some cases.</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._ask-expr)))"></a>&#8249;ask-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">ASK</span> <span class="bnf-meta">[</span><span class="bnf-lit">block</span><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._ask-branch%29%29%29" data-pltdoc="x">&#8249;ask-branch&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <span class="bnf-meta">[</span><span class="bnf-lit">|</span> <span class="bnf-lit">otherwise:</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a><span class="bnf-meta">]</span> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._ask-branch)))"></a>&#8249;ask-branch&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">|</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a> <span class="bnf-lit">then:</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a></p></blockquote><p>This ask expression:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>ask:
  | x == 0 then: 1
  | x &gt; 0 then: x
  | otherwise: x * -1
end</p></pre></pre><p>is equivalent to</p><pre class="pyret-block"><pre class="pyret-highlight"><p>if x == 0:
  1
else if x &gt; 0:
  x
else:
  x * -1
end</p></pre></pre><p>Similar to <span class="pyret-highlight"><span class="stt">if</span></span>, if an <span class="pyret-highlight"><span class="stt">otherwise:</span></span> branch isn&rsquo;t specified and no
branch matches, a runtime error results.</p><h5>2.1.9.15<tt>&nbsp;</tt><a name="(part._s~3acases-expr)"></a>Cases Expressions</h5><p>A cases expression consists of a datatype (in parentheses), an expression to
inspect (before the colon), and a number of branches.  It is intended to be
used in a structure parallel to a data definition.</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._cases-expr)))"></a>&#8249;cases-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">cases</span> <span class="bnf-lit">(</span> <a href="s_annotations.html#%28elem._%28bnf-prod._%28.Pyret._ann%29%29%29" data-pltdoc="x">&#8249;ann&#8250;</a> <span class="bnf-lit">)</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-meta">[</span><span class="bnf-lit">block</span><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._cases-branch%29%29%29" data-pltdoc="x">&#8249;cases-branch&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <span class="bnf-meta">[</span><span class="bnf-lit">|</span> <span class="bnf-lit">else</span> <span class="bnf-lit">=&gt;</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a><span class="bnf-meta">]</span> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._cases-branch)))"></a>&#8249;cases-branch&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">|</span> <span class="bnf-lit bnf-unknown">NAME</span> <span class="bnf-meta">[</span><a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._args%29%29%29" data-pltdoc="x">&#8249;args&#8250;</a><span class="bnf-meta">]</span> <span class="bnf-lit">=&gt;</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a></p></blockquote><p>The <span class="pyret-highlight"><span class="stt">check-ann</span></span> must be a type, like <a href="lists.html#%28part._lists_.List%29" data-pltdoc="x"><span class="stt">List</span></a>.  Then
<span class="pyret-highlight"><span class="stt">expr</span></span> is evaluated and checked against the given annotation.  If
it has the right type, the cases are then checked.</p><p>Cases should use the names of the variants of the given data type as the
<span class="stt">NAME</span>s of each branch.  In the branch that matches, the fields of the
variant are bound, in order, to the provided <span class="stt">args</span>, and the right-hand side
of the <span class="stt">=&gt;</span> is evaluated in that extended environment.  An exception results
if the wrong number of arguments are given.</p><p>An optional <span class="stt">else</span> clause can be provided, which is evaluated if no cases
match.  If no <span class="stt">else</span> clause is provided, a runtime error results.</p><p>For example, some cases expression on lists looks like:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>check:
  result = cases(List) [list: 1,2,3]:
    | empty =&gt; "empty"
    | link(f, r) =&gt; "link"
  end
  result is "link"

  result2 = cases(List) [list: 1,2,3]:
    | empty =&gt; "empty"
    | else =&gt; "else"
  end
  result2 is else

  result3 = cases(List) empty:
    | empty =&gt; "empty"
    | else =&gt; "else"
  end
  result3 is "empty"
end</p></pre></pre><p>If a field of the variant is a tuple, it can also be bound using a tuple binding.</p><p>For example, a cases expression on a list with tuples looks like:</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>check:
  result4 = cases(List) [list: {"a"; 1}, {"b"; 2}, {"c"; 3}]:
    | empty =&gt; "empty"
    | link({x;y}, r) =&gt; x
    | else =&gt; "else"
  end

  result4 is "a"
end</p></pre></pre></div></p></div><h5>2.1.9.16<tt>&nbsp;</tt><a name="(part._s~3afor-expr)"></a>For Expressions</h5><p>For expressions consist of the <span class="stt">for</span> keyword, followed by a list of
<span class="stt">binding from expr</span> clauses in parentheses, followed by a block:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._for-expr)))"></a>&#8249;for-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">for</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-lit">(</span> <span class="bnf-meta">[</span><span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._for-bind-elt%29%29%29" data-pltdoc="x">&#8249;for-bind-elt&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._for-bind%29%29%29" data-pltdoc="x">&#8249;for-bind&#8250;</a><span class="bnf-meta">]</span> <span class="bnf-lit">)</span> <a href="Declarations.html#%28elem._%28bnf-prod._%28.Pyret._return-ann%29%29%29" data-pltdoc="x">&#8249;return-ann&#8250;</a> <span class="bnf-meta">[</span><span class="bnf-lit">block</span><span class="bnf-meta">]</span> <span class="bnf-lit">:</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._for-bind-elt)))"></a>&#8249;for-bind-elt&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._for-bind%29%29%29" data-pltdoc="x">&#8249;for-bind&#8250;</a> <span class="bnf-lit">,</span>
<a name="(elem._(bnf-prod._(.Pyret._for-bind)))"></a>&#8249;for-bind&#8250;<span class="bnf-meta">:</span> <a href="Bindings.html#%28elem._%28bnf-prod._%28.Pyret._binding%29%29%29" data-pltdoc="x">&#8249;binding&#8250;</a> <span class="bnf-lit">from</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a></p></blockquote><p>The for expression is just syntactic sugar for a
<a href="#%28part._s~3alam-expr%29" data-pltdoc="x"><span class="stt">lam-expr</span></a> and a <a href="#%28part._s~3aapp-expr%29" data-pltdoc="x"><span class="stt">app-expr</span></a>.  An expression</p><pre class="pyret-block"><pre class="pyret-highlight"><p>for fexpr(arg1 :: ann1 from expr1, ...) -&gt; ann-return:
  block
end</p></pre></pre><p>is equivalent to:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>fexpr(lam(arg1 :: ann1, ...) -&gt; ann-return: block end, expr1, ...)</p></pre></pre><p>Using a <span class="stt">for-expr</span> can be a more natural way to call, for example, list
iteration functions because it puts the identifier of the function and the
value it draws from closer to one another.  Use of <span class="stt">for-expr</span> is a matter of
style; here is an example that compares <span class="stt">fold</span> with and without <span class="stt">for</span>:</p><pre class="pyret-block"><pre class="pyret-highlight"><p>for fold(sum from 0, number from [list: 1,2,3,4]):
  sum + number
end

fold(lam(sum, number): sum + number end, 0, [list: 1,2,3,4])</p></pre></pre><h5>2.1.9.17<tt>&nbsp;</tt><a name="(part._s~3atemplate-expr)"></a>Template (...) Expressions</h5><p>A template expression is three dots in a row:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._template-expr)))"></a>&#8249;template-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">...</span></p></blockquote><p>It is useful for a placeholder for other expressions in code-in-progress.  When
it is evaluated, it raises a runtime exception that indicates the expression it
is standing in for isn&rsquo;t yet implemented:</p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>fun list-sum(l :: List&lt;Number&gt;) -&gt; Number:
  cases(List&lt;Number&gt;) l:
    | empty =&gt; 0
    | link(first, rest) =&gt; first + ...
  end
end
check:
  list-sum(empty) is 0
  list-sum(link(1, empty)) raises "template-not-finished"
end</p></pre></pre></div></p></div><p>This is handy for starting a function (especially one with many cases) with
some tests written and others to be completed.</p><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>These other positions for <span class="stt">...</span> may be included in the future.</p></blockquote></blockquote></blockquote></div><div class="SIntrapara">The <span class="stt">...</span> expression can only appear where <span style="font-style: italic">expressions</span> can appear.
So it is not allowed in binding positions or annotation positions.  These are
not allowed:</div></p><div class="examples"><p><div class="SIntrapara"><span style="font-weight: bold">Examples:</span></div><div class="SIntrapara"><pre class="pyret-block"><pre class="pyret-highlight"><p>fun f(...): # parse error
  "todo"
end
x :: ... = 5 # parse error</p></pre></pre></div></p></div><p>Because templates are by definition unfinished, the presence of a
template expression in a block exempts that block from
<a href="Blocks.html#%28part._s~3ablocky-blocks%29" data-pltdoc="x">explicit-blockiness checking</a>.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="Statements.html" title="backward to &quot;2.1.8 Statements&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="s_forms.html" title="up to &quot;2.1 Language Constructs&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="s_annotations.html" title="forward to &quot;2.1.10 Annotations&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>