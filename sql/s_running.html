<!doctype HTML>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="codemirror.js"></script>
<script src="runmode.js"></script>
<script src="pyret.js"></script>
<script src="hilite.js"></script>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>5.3&nbsp;Running Code (Safely)</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="codemirror.css" title="default"/><link rel="stylesheet" type="text/css" href="pyret.css" title="default"/><link rel="stylesheet" type="text/css" href="styles.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Pyret</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Getting_Started.html" class="tocviewlink" data-pltdoc="x">Getting Started</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Language_Concepts.html" class="tocviewlink" data-pltdoc="x">Language Concepts</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="Builtins.html" class="tocviewlink" data-pltdoc="x">Builtins</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="Libraries.html" class="tocviewlink" data-pltdoc="x">Libraries</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="Internals.html" class="tocviewselflink" data-pltdoc="x">Internals</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td>5&nbsp;</td><td><a href="Internals.html" class="tocviewlink" data-pltdoc="x">Internals</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">5.1&nbsp;</td><td><a href="runtime.html" class="tocviewlink" data-pltdoc="x">Runtime API</a></td></tr><tr><td align="right">5.2&nbsp;</td><td><a href="ffi.html" class="tocviewlink" data-pltdoc="x">FFI Helpers</a></td></tr><tr><td align="right">5.3&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Running Code (Safely)</a></td></tr><tr><td align="right">5.4&nbsp;</td><td><a href="Modules.html" class="tocviewlink" data-pltdoc="x">Modules</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">&#9658;</a></td><td>5.3&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Running Code (Safely)</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tr><td align="right">5.3.1&nbsp;</td><td><a href="#%28part._.J.S_.Pretending_to_be_.Pyret%29" class="tocviewlink" data-pltdoc="x">JS Pretending to be Pyret</a></td></tr><tr><td align="right">5.3.2&nbsp;</td><td><a href="#%28part._.Asynchronous_.J.S_and_.Pyret%29" class="tocviewlink" data-pltdoc="x">Asynchronous JS and Pyret</a></td></tr><tr><td align="right">5.3.3&nbsp;</td><td><a href="#%28part._.Starting_a_.New_.Pyret_.Stack%29" class="tocviewlink" data-pltdoc="x">Starting a New Pyret Stack</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">5.3.1<tt>&nbsp;</tt></span><a href="#%28part._.J.S_.Pretending_to_be_.Pyret%29" class="tocsubseclink" data-pltdoc="x">JS Pretending to be Pyret</a></td></tr><tr><td><a href="#%28part._.Runtime_safe.Call%29" class="tocsubnonseclink" data-pltdoc="x"><span class="stt">Runtime.safe<span class="mywbr"> &nbsp;</span>Call</span></a></td></tr><tr><td><span class="tocsublinknumber">5.3.2<tt>&nbsp;</tt></span><a href="#%28part._.Asynchronous_.J.S_and_.Pyret%29" class="tocsubseclink" data-pltdoc="x">Asynchronous JS and Pyret</a></td></tr><tr><td><a href="#%28part._.Runtime_pause.Stack%29" class="tocsubnonseclink" data-pltdoc="x"><span class="stt">Runtime.pause<span class="mywbr"> &nbsp;</span>Stack</span></a></td></tr><tr><td><a href="#%28part._.Runtime_schedule.Pause%29" class="tocsubnonseclink" data-pltdoc="x"><span class="stt">Runtime.schedule<span class="mywbr"> &nbsp;</span>Pause</span></a></td></tr><tr><td><span class="tocsublinknumber">5.3.3<tt>&nbsp;</tt></span><a href="#%28part._.Starting_a_.New_.Pyret_.Stack%29" class="tocsubseclink" data-pltdoc="x">Starting a New Pyret Stack</a></td></tr><tr><td><a href="#%28part._.Runtime_run%29" class="tocsubnonseclink" data-pltdoc="x"><span class="stt">Runtime.run</span></a></td></tr><tr><td><span class="tocsublinknumber">5.3.3.1<tt>&nbsp;</tt></span><a href="#%28part._s~3asynchronous%29" class="tocsubseclink" data-pltdoc="x">Synchronous vs. Asynchronous Execution</a></td></tr><tr><td><span class="tocsublinknumber">5.3.3.2<tt>&nbsp;</tt></span><a href="#%28part._s~3aresult-structures%29" class="tocsubseclink" data-pltdoc="x">Result Data Structures</a></td></tr><tr><td><a href="#%28part._.Runtime_make.Success.Result%29" class="tocsubnonseclink" data-pltdoc="x"><span class="stt">Runtime.make<span class="mywbr"> &nbsp;</span>Success<span class="mywbr"> &nbsp;</span>Result</span></a></td></tr><tr><td><a href="#%28part._.Runtime_is.Success.Result%29" class="tocsubnonseclink" data-pltdoc="x"><span class="stt">Runtime.is<span class="mywbr"> &nbsp;</span>Success<span class="mywbr"> &nbsp;</span>Result</span></a></td></tr><tr><td><a href="#%28part._.Runtime...Success.Result_result%29" class="tocsubnonseclink" data-pltdoc="x"><span class="stt">Runtime.Success<span class="mywbr"> &nbsp;</span>Result.result</span></a></td></tr><tr><td><a href="#%28part._.Runtime_make.Failure.Result%29" class="tocsubnonseclink" data-pltdoc="x"><span class="stt">Runtime.make<span class="mywbr"> &nbsp;</span>Failure<span class="mywbr"> &nbsp;</span>Result</span></a></td></tr><tr><td><a href="#%28part._.Runtime_is.Failure.Result%29" class="tocsubnonseclink" data-pltdoc="x"><span class="stt">Runtime.is<span class="mywbr"> &nbsp;</span>Failure<span class="mywbr"> &nbsp;</span>Result</span></a></td></tr><tr><td><a href="#%28part._.Runtime...Failure.Result_exn%29" class="tocsubnonseclink" data-pltdoc="x"><span class="stt">Runtime.Failure<span class="mywbr"> &nbsp;</span>Result.exn</span></a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="ffi.html" title="backward to &quot;5.2 FFI Helpers&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="Internals.html" title="up to &quot;5 Internals&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Modules.html" title="forward to &quot;5.4 Modules&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h4>5.3<tt>&nbsp;</tt><a name="(part._s~3arunning)"></a>Running Code (Safely)</h4><p>In order to support both responsive evaluation and simulate an arbitrarily deep
stack, Pyret has an evaluation model that does not exactly match JavaScript&rsquo;s.</p><p>When a Pyret function is compiled, it gets an extra <span class="stt">try/catch</span> handler
wrapped around it that listens for special Pyret-specific exceptions.  That
means when it&rsquo;s running, we can think of the stack frame of the function as
having an extra layer around it:</p><p><img src="frames.png" alt="" width="335" height="181"/></p><p>When a Pyret function detects (via a counter stored in the runtime) that the
stack depth is approaching the maximum that JavaScript can tolerate, it throws
an exception:</p><p><img src="exception.png" alt="" width="200" height="170"/></p><p>When the exception is encountered by one of the handlers, it attaches enough
information to the exception to restart the handler&rsquo;s frame before allowing the
exception to coninue:</p><p><img src="first-frame.png" alt="" width="482" height="196"/></p><p>This continues through the entire stack, storing a list of Pyret stack frames
stored on the exception object:</p><p><img src="many-frames.png" alt="" width="545" height="174"/></p><p>Until finally, the entire Pyret stack is reified on the exception object, and
all the JavaScript frames from the Pyret functions are gone:</p><p><img src="stack.png" alt="" width="151" height="129"/></p><p>This exception is caught by Pyret&rsquo;s toplevel, which restarts the
<span style="font-style: italic">bottommost</span> element of the stack, which now has nothing above it, instead
of a full stack.  It can make progress with the available JS stack.  The
runtime can store the existing Pyret stack and add to it if the JS stack runs
out again.</p><p>This works just fine if all that&rsquo;s running is Pyret code.  However, there are
two cases where JavaScript code that interacts with Pyret needs to be handled
delicately.</p><h5>5.3.1<tt>&nbsp;</tt><a name="(part._.J.S_.Pretending_to_be_.Pyret)"></a>JS Pretending to be Pyret</h5><p>Many library use cases, like data structures and convenience functions, are
written as JavaScript code that emulates Pyret function calls.  However, if JS
code calls back into Pyret code, care is in order.  Here&rsquo;s what the stack looks
like if Pyret calls JavaScript that calls Pyret again:</p><p><img src="callback.png" alt="" width="310" height="391"/></p><p>If the stack limit is reached and an exception thrown, the bottom Pyret frames
will have their intermediate state stored:</p><p><img src="callback-bottom.png" alt="" width="302" height="411"/></p><p>But the pure JavaScript frames have no stack management handlers installed, so
they are skipped without consideration for any intermediate state they may
contain.</p><p><img src="callback-middle.png" alt="" width="331" height="411"/></p><p>The resulting stack doesn&rsquo;t accurately represent the program that was being
executed.  It is, quite literally, nonsense, because a Pyret function will
return directly to another Pyret function, ignoring all of the intermediate
JavaScript logic.  Using this pattern without any guards or protection will
create programs that simply produce wrong answers.</p><p><img src="callback-final.png" alt="" width="255" height="433"/></p><p>Pyret&rsquo;s runtime defines a function called <a href="#%28part._.Runtime_safe.Call%29" data-pltdoc="x"><span class="stt">Runtime.safeCall</span></a>
that allows pure JavaScript to participate in the Pyret stack.</p><div class="function"><p><div class="SIntrapara"><span class="NoteBox"><span class="NoteContent"><span class="stt">!&#8594;</span> means this function is not <a href="" data-pltdoc="x">stack safe</a></span></span></div><div class="SIntrapara"><div class="boxed"><p><a name="(part._.Runtime_safe.Call)" class="pyret-code"></a><span class="stt">Runtime.safeCall</span><span class="stt">(</span><span class="stt">(&#8594; a)</span><span class="stt">, </span><span class="stt">(a &#8594; b)</span><span class="stt">) !&#8594; </span><span class="stt">b</span></p></div></div></p></div><p><a href="#%28part._.Runtime_safe.Call%29" data-pltdoc="x"><span class="stt">Runtime.safeCall</span></a> combines the two provided functions in a
special stack frame:</p><p><img src="safe-call.png" alt="" width="317" height="196"/></p><p>The first argument is called, and in normal execution, its return value is
passed to the second function.  The second function&rsquo;s return value is then the
return value of the whole call.  However, if a stack exception occurs, the
<span style="font-style: italic">second</span> function is registered as the frame stored on the Pyret stack:</p><p><img src="safe-call-catch.png" alt="" width="275" height="235"/></p><p>This means that in the simulated stack, the second callback (blue in the
picture), will receive the result of the last call to a stack-managed function
from the first callback (pink in the picture):</p><p><img src="return-1.png" alt="" width="289" height="214"/></p><p>Then, when the second callback (blue) is run, it&rsquo;s return value will be passed
up the stack to the Pyret function that called into the use of <span class="stt">safeCall</span>:</p><p><img src="return-2.png" alt="" width="257" height="214"/></p><p>The usual pattern for using <a href="#%28part._.Runtime_safe.Call%29" data-pltdoc="x"><span class="stt">Runtime.safeCall</span></a> is with a single
call to a Pyret function, or another function that calls a Pyret function.  As
long as all the calls to Pyret functions are in tail position in safeCalls, no
information will be lost.</p><p><span style="font-weight: bold">Examples</span></p><p>Calling <span class="stt">torepr</span> can consume a lot of stack (for serializing large data
structures), so JavaScript-implemented <span class="stt">torepr</span> methods often need to use
<span class="stt">safeCall</span>.  For example, a function that does work with the result of a
<span class="stt">torepr</span> call needs to use <span class="stt">safeCall</span> to capture the result correctly:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">function makeDataType(val) {</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">function torepr(self, toreprRecursive) {</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return runtime.safeCall(function() {</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return toreprRecursive.app(val);</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">}, function(valAsString) {</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return "Value was: " + valAsString</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">})</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return runtime.makeObject({</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">_torepr: runtime.makeMethod1(torepr)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">});</span></p></td></tr><tr><td><p><span class="stt">}</span></p></td></tr></table></p><p><span class="NoteBox"><span class="NoteContent">We haven&rsquo;t found a way to turn this into an error, so testing and code review
are the only real protections.  The best way to test for this kind of problem
is to pass deeply recursive callbacks into the JS library, which can trigger
odd behavior.  If you have suggestions for patterns or tools to make this less
error-prone, let us know.</span></span>
If instead it was written as:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">function makeDataType(val) {</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">function torepr(self, toreprRecursive) {</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">var valAsString = toreprRecursive.app(val);</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return "Value was: " + valAsString;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return runtime.makeObject({</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">_torepr: runtime.makeMethod1(torepr)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">});</span></p></td></tr><tr><td><p><span class="stt">}</span></p></td></tr></table></p><p>then, a <span class="stt">torepr</span> call on the resulting object could use up all the stack
while evaluating <span class="stt">toreprRecursive.app(val)</span>, causing the string
concatenation in the return to simply be ignored.</p><h5>5.3.2<tt>&nbsp;</tt><a name="(part._.Asynchronous_.J.S_and_.Pyret)"></a>Asynchronous JS and Pyret</h5><p>Lots of JavaScript code works asynchronously, with callbacks that are
registered to be invoked after the stack clears.  The control flow of these
callbacks interacts with Pyret&rsquo;s stack infrastructure.  Most callback-using
JavaScript code simply returns <span class="stt">undefined</span> immediately, and all further
computation happens in either success or failure continuations.  This doesn&rsquo;t
play nicely with Pyret&rsquo;s stack-based control flow, because Pyret functions
expect a meaningful return value.<span class="NoteBox"><span class="NoteContent">We could require that all Pyret code
that uses JS callback libraries use Pyret callbacks, but it&rsquo;s hardly elegant to
require that all students learn to use callbacks before they can import an
image.</span></span></p><p><img src="ajax.png" alt="" width="568" height="219"/></p><p>In order to weave the control flow of Pyret through the success and failure
continuations of callbacks, the runtime provides a way to pause and reify the
Pyret stack for later resumption.</p><div class="function"><div class="boxed"><p><a name="(part._.Runtime_pause.Stack)" class="pyret-code"></a><span class="stt">Runtime.pauseStack</span><span class="stt">(</span><span class="stt">(Restarter &#8594; Undefined)</span><span class="stt">) &#8594; </span><span class="stt">Undefined</span></p></div></div><p>When <span class="stt">pauseStack</span> is called, a special <span style="font-style: italic">pause</span> exception is thrown,
that stores the callback passed in as the argument to <span class="stt">pauseStack</span>.  The
pause exception collects Pyret stack frames in the same way as a stack
exception, it just keeps track of the callback as well:</p><p><img src="pause.png" alt="" width="576" height="247"/></p><p>The pause exception is handled specially at the toplevel, by creating a
<span class="stt">Restarter</span> object that is capable of resuming, stopping, or signalling an
error at the point the Pyret stack was paused.  This <span class="stt">Restarter</span> is passed
into the callback argument to <span class="stt">pauseStack</span>, which can then
<span style="font-style: italic">asynchronously</span> restart the Pyret process:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">Restarter :: {</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">resume: PyretVal &#8594; Undefined,</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">error: (PyretError U PyretVal) &#8594; Undefined,</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">break: &#8594; Undefined</span></p></td></tr><tr><td><p><span class="stt">}</span></p></td></tr></table></p><p>Example:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">myRuntime.pauseStack(function(restarter) {</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">var request = $.ajax("/api");</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">request.then(function(answer) {</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">restarter.resume(toPyretResponse(answer));</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">});</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">request.fail(function(err) {</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">restarter.error(myRuntime.ffi.makeMessageException("Request failed"));</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">});</span></p></td></tr><tr><td><p><span class="stt">});</span></p></td></tr></table></p><p>Some things to note:</p><ul><li><p>It is an error to call more than one of <span class="stt">resume</span>/<span class="stt">error</span>/<span class="stt">break</span>:
a <span class="stt">Restarter</span> is not a continuation that can be invoked multiple times.</p></li><li><p>If none of the callbacks are ever called, from the point of view of the
running Pyret process, the program is in an infinite loop (for example, the
IDE may show a "running" GIF forever).  This includes the case where
executing the callback ends in an error.  So, using <span class="stt">pauseStack</span>
requires some care in writing robust JavaScript code, or odd behavior can
result.</p></li></ul><div class="function"><div class="boxed"><p><a name="(part._.Runtime_schedule.Pause)" class="pyret-code"></a><span class="stt">Runtime.schedulePause</span><span class="stt">(</span><span class="stt">(Restarter &#8594; Undefined)</span><span class="stt">) &#8594; </span><span class="stt">Undefined</span></p></div></div><p>Similar to <a href="#%28part._.Runtime_pause.Stack%29" data-pltdoc="x"><span class="stt">Runtime.pauseStack</span></a>, but used from outside the
runtime (e.g. in the REPL), to schedule a pause.  Since the point of
interruption (and resumption) is not predictable from outside the Pyret thread,
the <span class="stt">resume</span> method of the <span class="stt">Restarter</span> for <span class="stt">schedulePause</span> ignores any
value passed to it; it always resumes the computation exactly as it would have
continued had it not been paused.</p><p>If <a href="#%28part._.Runtime_schedule.Pause%29" data-pltdoc="x"><span class="stt">Runtime.schedulePause</span></a> is called during a synchronous
<a href="#%28part._.Runtime_run%29" data-pltdoc="x"><span class="stt">Runtime.run</span></a>, the runtime will still wait until the next stack
exception to call the given <span class="stt">Restarter</span>.  If called during an asynchronous
run, the next time a setTimeout is triggered, the <span class="stt">Restarter</span> will be called.</p><p>If <a href="#%28part._.Runtime_schedule.Pause%29" data-pltdoc="x"><span class="stt">Runtime.schedulePause</span></a> is called multiple times before
Pyret checks for scheduled pauses, the last call&rsquo;s <span class="stt">Restarter</span> is used, and
any earlier calls are ignored.</p><h5>5.3.3<tt>&nbsp;</tt><a name="(part._.Starting_a_.New_.Pyret_.Stack)"></a>Starting a New Pyret Stack</h5><p>The description of <a href="#%28part._.Runtime_safe.Call%29" data-pltdoc="x"><span class="stt">Runtime.safeCall</span></a> and <a href="#%28part._.Runtime_pause.Stack%29" data-pltdoc="x"><span class="stt">Runtime.pauseStack</span></a> assume that the calls are being made in a running Pyret execution
context.  This is the case for most library code that would get run via
<span class="pyret-highlight"><span class="stt">import</span></span>, and be using external APIs.</p><p>However, some applications may need to start new Pyret instances from scratch.
In order for the special <span class="stt">PauseExceptions</span> and <span class="stt">StackExceptions</span> to be
caught at the top level and correctly restarted, the handlers need to be
correctly installed.  This is done by <a href="#%28part._.Runtime_run%29" data-pltdoc="x"><span class="stt">Runtime.run</span></a>:</p><div class="function"><div class="boxed"><dl class="multiline-args"><dt class=""><a name="(part._.Runtime_run)" class="pyret-code"></a><span class="stt">Runtime.run</span>(</dt><dt class="indent-arg"><span class="stt">(Runtime, Namespace &#8594; a)</span></dt><dt class="indent-arg"><span class="stt">Namespace</span></dt><dt class="indent-arg"><span class="stt">RunOptions</span></dt><dt class="indent-arg"><span class="stt">(RunResult&lt;a&gt; &#8594; Undef)</span></dt><dt class=""><span class="stt">)</span></dt><dt class=""><span class="stt">&#8594; Undef</span></dt></dl></div></div><p>The first argument is the program to run, which takes a <span class="stt">Runtime</span> (which is
always the same as the runtime <span class="stt">run</span> is called on), and a <span class="stt">Namespace</span> as
arguments.  Pyret programs are compiled to look for any global identifiers in
<span class="stt">Namespace</span>.  The second argument is the <span class="stt">Namespace</span> passed to the
function to run (adding to the namespace is useful for e.g. putting
REPL-defined identifiers into scope).  <span class="stt">RunOptions</span> has only one field:
<span class="stt">sync</span>, which is a boolean indicating if the program should be run
<span style="font-style: italic">synchronously</span> or not.  This is described more in
<a href="#%28part._s~3asynchronous%29" data-pltdoc="x">Synchronous vs. Asynchronous Execution</a>.  Finally, the last argument is a callback that gets
either a <span class="stt">Success</span> or <span class="stt">Failure</span> result, described in
<a href="#%28part._s~3aresult-structures%29" data-pltdoc="x">Result Data Structures</a>.</p><p>Only one <span class="stt">run</span> call can be active for a given <span class="stt">runtime</span> at once.  If it
is called more than once, an error that says <span class="stt">"run called while already
running"</span> will be raised.  New calls to <a href="#%28part._.Runtime_run%29" data-pltdoc="x"><span class="stt">Runtime.run</span></a> should
only be used at the logical start of a Pyret program&rsquo;s execution (e.g. running
the definitions window, running a REPL entry, running a standalone test case
start-to-finish), not for loading libraries, interacting with native JS APIs,
or managing asynchronous APIs.</p><h5>5.3.3.1<tt>&nbsp;</tt><a name="(part._s~3asynchronous)"></a>Synchronous vs. Asynchronous Execution</h5><p>The <span class="stt">sync</span> flag passed to <a href="#%28part._.Runtime_run%29" data-pltdoc="x"><span class="stt">Runtime.run</span></a> changes how stack
pauses are managed.  In synchronous mode (<span class="stt">sync: true</span>), when a stack or
pause exception reaches the top level, it is immediately restarted.  This is
the fastest option, and is the default for Pyret running from the command-line.</p><p>However, when executing synchronously, Pyret never yields to the event loop.
If <span class="stt">sync: true</span> were used in a context with user interaction, like a browser
page, the UI thread would never get a chance to run.  If <span class="stt">sync</span> is set to
<span class="stt">false</span>, when the stack limit is reached, or a pause execption is thrown, it
is restarted after first yielding to the event loop (using <span class="stt">setTimeout</span>).
This provides a window for the browser to process click and key events,
avoiding page lockup.  This also gives the ability for UI elements to trigger
calls to <a href="#%28part._.Runtime_schedule.Pause%29" data-pltdoc="x"><span class="stt">Runtime.schedulePause</span></a>, which will call back to the
pauser the next time the Pyret thread restarts.</p><h5>5.3.3.2<tt>&nbsp;</tt><a name="(part._s~3aresult-structures)"></a>Result Data Structures</h5><div class="function"><div class="boxed"><p><a name="(part._.Runtime_make.Success.Result)" class="pyret-code"></a><span class="stt">Runtime.makeSuccessResult</span><span class="stt">(</span><span class="stt">a</span><span class="stt">) &#8594; </span><span class="stt">SuccessResult&lt;a&gt;</span></p></div></div><p>Represents a successful completion of a Pyret execution with
<a href="#%28part._.Runtime_run%29" data-pltdoc="x"><span class="stt">Runtime.run</span></a>.</p><div class="function"><div class="boxed"><p><a name="(part._.Runtime_is.Success.Result)" class="pyret-code"></a><span class="stt">Runtime.isSuccessResult</span><span class="stt">(</span><span class="stt">Any</span><span class="stt">) &#8594; </span><span class="stt">Bool</span></p></div></div><p>Checks if a value is a <span class="stt">SuccessResult</span>.</p><div class="function"><div class="boxed"><p><a name="(part._.Runtime...Success.Result_result)" class="pyret-code"></a><span class="stt">Runtime.SuccessResult.result</span> :: <span class="stt">Any</span></p></div></div><p>The field that stores the answer of a <span class="stt">SuccessResult</span>.</p><div class="function"><div class="boxed"><p><a name="(part._.Runtime_make.Failure.Result)" class="pyret-code"></a><span class="stt">Runtime.makeFailureResult</span><span class="stt">(</span><span class="stt">a</span><span class="stt">) &#8594; </span><span class="stt">FailureResult&lt;a&gt;</span></p></div></div><p>Represents a Pyret execution with <a href="#%28part._.Runtime_run%29" data-pltdoc="x"><span class="stt">Runtime.run</span></a> that ended in
some kind of exception (either from Pyret or an internal JavaScript error).</p><div class="function"><div class="boxed"><p><a name="(part._.Runtime_is.Failure.Result)" class="pyret-code"></a><span class="stt">Runtime.isFailureResult</span><span class="stt">(</span><span class="stt">Any</span><span class="stt">) &#8594; </span><span class="stt">Bool</span></p></div></div><p>Checks if a value is a <span class="stt">FailureResult</span>.</p><div class="function"><div class="boxed"><p><a name="(part._.Runtime...Failure.Result_exn)" class="pyret-code"></a><span class="stt">Runtime.FailureResult.exn</span> :: <span class="stt">Any</span></p></div></div><p>The field that stores the exception value of a <span class="stt">FailureResult</span>.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="ffi.html" title="backward to &quot;5.2 FFI Helpers&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="Internals.html" title="up to &quot;5 Internals&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Modules.html" title="forward to &quot;5.4 Modules&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>